{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Simulate_C_lang",
  "steps": [
    {
      "file": "c_based_language.c",
      "description": "Call Process File:\r\n\r\nMao ni ang base function sa pag handle sa pag open sa source code file , initialize sa lexer, parser , ast , tac , ug generate sa aseembly ug machine code.\r\nMoa ni siya nga function tig call sa other function para ma process ang source code.",
      "line": 348,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "init_lexer :\r\n\r\nInitialize the lexer . Set all lexer global variables to initial state which would be zero or null.",
      "line": 3023,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "init_symbol table :\r\n\r\ninitialze symbol table . Clear all global variables relating to the symbol table and set it to initial values",
      "line": 3024,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "advance_token.\r\n\r\nStart the lexer to get the initial token, as the head/current token being parsed for the ast/parser",
      "line": 3025,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "call the parser, which returns an AST node pointer to the starting or root node for the parse tree.",
      "line": 3026,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "Starting Production RULE for the CFG which is the <program> -> <statement_list> TOK_EOF\r\n\r\nDiri mag sugod and parse tree.",
      "line": 2220,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "Parse the statement_list rule which is <statement_list> -> <stmt> <stmt_list> | e",
      "line": 2222,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "Check if format follows the parse_program / program production rule which states that stmt_list should be followed by TOK_EOF .\r\nIf not then it adds error to the errors list.",
      "line": 2223,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "If everything is valid. Then create a node in the ast tree for the current executed production .",
      "line": 2227,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "Check if the current_token given by the lexer is of type TOK_EOF then signifies that we have reached the end of the source code meaning that there is no more tokens to parse and it is not valid for stmt_list rule.\r\nReturn NULL for the NODE.",
      "line": 2234,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "This will generate a node for the current production rule and also generate the head for the parse_stmt sub tree.",
      "line": 2239,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "Check if the current token is a data type token ",
      "line": 2290,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "generate the current node for the init_list but also generate the head for the sub tree of production rule <init>.\r\n\r\nIf it is invalid, then just return null for the current node.",
      "line": 2351,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "Check if the current token is an identifier/ variable . If it is not then add an error to the errors lists.",
      "line": 2402,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "create the node for the current tree and generate the head for the <expr> subtree.",
      "line": 2431,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    },
    {
      "file": "c_based_language.c",
      "description": "generate node for the current production and generate the subtree for the additive expression production rule.",
      "line": 2454,
      "contents": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n/* ----------------- Typedefinitions for Enums ----------------- */\r\n\r\n// Enum definition for Token Types\r\ntypedef enum\r\n{\r\n    TOK_INT,          // Token for integers data type \"int\"\"\r\n    TOK_CHAR,         // Token for characters data type \"char\"\"\r\n    TOK_IDENT,        // Token for Identifiers\r\n    TOK_NUMBER,       // Token for Numbers\r\n    TOK_CHAR_LITERAL, // Token for Character Literals ex. 'A'\r\n    TOK_ASSIGN,       // Token for Assignment Operator '='\r\n    TOK_PLUS_ASSIGN,  // Token for '+='\r\n    TOK_MINUS_ASSIGN, // Token for '-='\r\n    TOK_MULT_ASSIGN,  // Token for '*='\r\n    TOK_DIV_ASSIGN,   // Token for '/='\r\n    TOK_PLUS,         // Token for Addition Operator '+'\r\n    TOK_MINUS,        // Token for Subtraction Operator '-'\r\n    TOK_MULT,         // Token for Multiplication Operator '*'\r\n    TOK_DIV,          // Token for Division Operator '/'\r\n    TOK_SEMICOLON,    // Token for Semicolon ';'\r\n    TOK_LPAREN,       // Token for Left Parenthesis '('\r\n    TOK_RPAREN,       // Token for Right Parenthesis ')'\r\n    TOK_COMMA,        // Token for Comma ','\r\n    TOK_INCREMENT,    // Token for Increment Operator '++'\r\n    TOK_DECREMENT,    // Token for Decrement Operator '--'\r\n    TOK_EOF,          // Token for End of File\r\n    TOK_ERROR         // Token for Error/ Unknown Token\r\n} TokenType;\r\n\r\n// Enum definition for Token Identifiers Datatype\r\ntypedef enum\r\n{\r\n    TYPE_INT,    // Integer Data Type\r\n    TYPE_CHAR,   // Character Data Type\r\n    TYPE_ERROR,  // Error Data Type\r\n    TYPE_UNKNOWN // Unknown Data Type\r\n} DataType;\r\n\r\n// Enum definition for AST Node Types\r\ntypedef enum\r\n{\r\n    NODE_VAR_DECL,       // Node for Variable Declaration\r\n    NODE_ASSIGN,         // Node for Assignment Operation\r\n    NODE_BIN_OP,         // Node for Binary Operations\r\n    NODE_NUMBER,         // NOde for Numbers\r\n    NODE_IDENT,          // Node for Identifiers\r\n    NODE_PROGRAM,        // Node for Program Root\r\n    NODE_STATEMENT_LIST, // Node for Statement List\r\n    NODE_DECL_LIST,      // Node for Declaration List\r\n    NODE_CHAR_LITERAL,   // Node for Character Literals\r\n    NODE_UNARY_OP,       // Node for Unary Operations\r\n    NODE_COMMA_EXPR      // Node for Comma Expressions\r\n} NodeType;\r\n\r\n// Enum definition for Three Address Code (TAC) Types\r\ntypedef enum\r\n{\r\n    TAC_ASSIGN, // TAC for Assignment Operation\r\n    TAC_ADD,    // TAC for Addition Operation\r\n    TAC_SUB,    // TAC for Subtraction Operation\r\n    TAC_MUL,    // TAC for Multiplication Operation\r\n    TAC_DIV,    // TAC for Division Operation\r\n    TAC_COPY,   // TAC for Copy Operation\r\n    TAC_INC,    // TAC for Increment Operation\r\n    TAC_DEC,    // TAC for Decrement Operation\r\n} TACType;\r\n\r\n// Enum definition for MIPS Instruction Types\r\ntypedef enum\r\n{\r\n    MIPS_DADDIU, // Enumeration for MIPS DADDIU Instruction\r\n    MIPS_DADDU,  // Enumeration for MIPS DADDU Instruction\r\n    MIPS_DSUBU,  // Enumeration for MIPS DSUBU Instruction\r\n    MIPS_DMULT,  // Enumeration for MIPS DMULT Instruction\r\n    MIPS_DDIV,   // Enumeration for MIPS DDIV Instruction\r\n    MIPS_MFLO,   // Enumeration for MIPS MFLO Instruction\r\n    MIPS_SD,     // Enumeration for MIPS SD Instruction\r\n    MIPS_SB,     // Enumeration for MIPS SB Instruction\r\n    MIPS_LD,     // Enumeration for MIPS LD Instruction\r\n    MIPS_LB,     // Enumeration for MIPS LB Instruction\r\n} MIPSInstructionType;\r\n\r\n/* ----------------- Struct Definitions ----------------- */\r\n\r\n/*\r\n Token:\r\n Represents a lexical token produced by the lexer.\r\n Fields:\r\n   - type: the kind of token (keyword, identifier, number, etc.)\r\n   - value: the string value of the token (e.g., variable name, literal)\r\n   - line: the line number in the source code where the token was found, used for error reporting\r\n*/\r\ntypedef struct\r\n{\r\n    TokenType type;\r\n    char value[32];\r\n    int line;\r\n} Token;\r\n\r\n/**\r\n * Symbol structure definition\r\n * Represents a variable in the symbol table.\r\n *   name           - variable name (string)\r\n *   type           - variable data type (DataType enum)\r\n *   declared       - flag indicating if declared (1 = yes)\r\n *   memory_offset  - offset in memory for code generation\r\n *   next           - pointer to next symbol in the table (linked list)\r\n */\r\ntypedef struct Symbol\r\n{\r\n    char *name;\r\n    DataType type;\r\n    int declared;\r\n    int line;\r\n    int memory_offset;\r\n    struct Symbol *next;\r\n} Symbol;\r\n\r\n/**\r\n * ASTNode structure definition\r\n * Represents a node in the Abstract Syntax Tree (AST).\r\n *   type       - the kind of AST node (NodeType enum)\r\n *   token      - the token associated with this node (for identifiers, literals, operators, etc.)\r\n *   data_type  - the semantic type of the node (int, char, etc.), used for type checking\r\n *   left       - pointer to the left child node (used for binary operations, declarations, etc.)\r\n *   right      - pointer to the right child node (used for binary operations, lists, etc.)\r\n */\r\ntypedef struct ASTNode\r\n{\r\n    NodeType type;\r\n    Token token;\r\n    DataType data_type;\r\n    struct ASTNode *left;\r\n    struct ASTNode *right;\r\n} ASTNode;\r\n\r\n/**\r\n * ErrorInfo structure definition\r\n * Represents an error encountered during semantic analysis.\r\n *  line       - the line number where the error occurred\r\n *  message    - descriptive error message\r\n *  next       - pointer to the next error in the linked list\r\n */\r\ntypedef struct ErrorInfo\r\n{\r\n    int line;\r\n    char message[256];\r\n    struct ErrorInfo *next;\r\n} ErrorInfo;\r\n\r\n/**\r\n * TACNode structure definition\r\n * Represents a Three Address Code (TAC) instruction.\r\n * type       - the kind of TAC instruction (TACType enum)\r\n * result     - the result variable/register of the instruction\r\n * arg1       - the first argument variable/register of the instruction\r\n * arg2       - the second argument variable/register of the instruction\r\n * prev       - pointer to the previous TAC instruction in the linked list\r\n * next       - pointer to the next TAC instruction in the linked list\r\n */\r\ntypedef struct TACNode\r\n{\r\n    TACType type;\r\n    char *result;\r\n    char *arg1;\r\n    char *arg2;\r\n    struct TACNode *prev;\r\n    struct TACNode *next;\r\n} TACNode;\r\n\r\n/**\r\n * MIPSInstruction structure definition\r\n * Represents a MIPS assembly instruction.\r\n * type       - the kind of MIPS instruction (MIPSInstructionType enum)\r\n * rt         - target register\r\n * rs         - source register\r\n * rd         - destination register\r\n * base       - base register for memory operations\r\n * offset     - offset for memory operations\r\n * immediate  - immediate value for instructions that use it\r\n * prev       - pointer to the previous instruction in the linked list\r\n * next       - pointer to the next instruction in the linked list\r\n */\r\ntypedef struct MIPSInstruction\r\n{\r\n    MIPSInstructionType type;\r\n    char *rt;\r\n    char *rs;\r\n    char *rd;\r\n    char *base;\r\n    char *offset;\r\n    char *immediate;\r\n    struct MIPSInstruction *prev;\r\n    struct MIPSInstruction *next;\r\n} MIPSInstruction;\r\n\r\n/* ----------------- Program Configuration and Global Vars ----------------- */\r\n\r\nbool DEBUG_MODE = true;                                                                  // Set to true to enable debug output\r\nchar *input;                                                                             // Input source code string\r\nint position = 0;                                                                        // Current position in input string\r\nint current_line = 1;                                                                    // Current line number for error reporting\r\nSymbol *symbol_table = NULL;                                                             // Head of the symbol table linked list\r\nint semantic_errors = 0;                                                                 // Count of semantic errors found\r\nToken current_token;                                                                     // Current token being processed by the lexer\r\nint current_memory_offset = 0;                                                           // Global memory offset counter (MIPS64 alignment: 8 bytes)\r\nint temp_registers_used[10] = {0};                                                       // Track which t0-t9 are in use\r\nchar *temp_reg_names[10] = {\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\"}; // Temp register names\r\nint temp_counter = 0;                                                                    // For tracking usage, not for naming\r\nErrorInfo *error_list = NULL;                                                            // Head of the error linked list\r\nint error_count = 0;                                                                     // Count of errors recorded\r\nMIPSInstruction *assembly_code = NULL;                                                   // Head of the MIPS assembly instruction linked list\r\n\r\n/* ----------------- Function Prototypes ----------------- */\r\n\r\nchar *read_file(char *filename);\r\n\r\nvoid process_file(char *filename);\r\n\r\n// Lexter Function Prototypes\r\nvoid init_lexer(const char *input_str);\r\nToken get_next_token();\r\nvoid advance_token();\r\nToken create_token(TokenType type, const char *value);\r\nint is_identifier_char(char c);\r\n\r\n// Parser Function Prototypes\r\nint expect_token(TokenType expected);\r\nvoid parser_error(const char *message);\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right);\r\nvoid print_ast(ASTNode *node, int depth);\r\nvoid free_ast(ASTNode *node);\r\nvoid print_indent(int depth);\r\n\r\n/**\r\n        <program> ::= <stmt_list> TOK_EOF\r\n\r\n        <stmt_list> ::= <stmt> <stmt_list_tail>\r\n        <stmt_list_tail> ::= <stmt> <stmt_list_tail> | ε\r\n\r\n        <stmt> ::= <decl_stmt> <semi_tail>\r\n                | <assign_stmt> <semi_tail>\r\n                | <unary_stmt> <semi_tail>\r\n                | <semi_tail>\r\n\r\n        <semi_tail> ::= TOK_SEMICOLON <semi_tail> | ε\r\n\r\n        <decl_stmt> ::= <type_spec> <init_list>\r\n        <type_spec> ::= TOK_INT | TOK_CHAR\r\n        <init_list> ::= <init> <init_list_tail>\r\n        <init_list_tail> ::= TOK_COMMA <init> <init_list_tail> | ε\r\n        <init> ::= TOK_IDENT [ TOK_ASSIGN <assignment_expression> ]\r\n\r\n        <assign_stmt> ::= <assignment_expression>\r\n        <assignment_expression> ::= <additive_expression> <assign_op_tail>\r\n        <assign_op_tail> ::= TOK_ASSIGN <comma_expression>\r\n                        | TOK_PLUS_ASSIGN <comma_expression>\r\n                        | TOK_MINUS_ASSIGN <comma_expression>\r\n                        | TOK_MULT_ASSIGN <comma_expression>\r\n                        | TOK_DIV_ASSIGN <comma_expression>\r\n                        | ε\r\n\r\n        <comma_expression> ::= <assignment_expression> <comma_tail>\r\n        <comma_tail> ::= TOK_COMMA <comma_expression> | ε\r\n\r\n        <additive_expression> ::= <term> <additive_tail>\r\n        <additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n        <term> ::= <factor> <term_tail>\r\n        <term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n\r\n        <factor> ::= TOK_NUMBER\r\n                | TOK_CHAR_LITERAL\r\n                | TOK_INCREMENT TOK_IDENT\r\n                | TOK_DECREMENT TOK_IDENT\r\n                | TOK_IDENT <postfix_op>\r\n                | TOK_LPAREN <comma_expression> TOK_RPAREN\r\n                | TOK_PLUS <factor>\r\n                | TOK_MINUS <factor>\r\n\r\n        <postfix_op> ::= TOK_INCREMENT | TOK_DECREMENT | ε\r\n        <unary_stmt> ::= TOK_INCREMENT TOK_IDENT | TOK_DECREMENT TOK_IDENT\r\n\r\n */\r\n\r\nASTNode *parse_program();\r\nASTNode *parse_stmt_list();\r\nASTNode *parse_stmt();\r\nASTNode *parse_declaration();\r\nASTNode *parse_init_list(Token type_token);\r\nASTNode *parse_init(Token type_token);\r\nASTNode *parse_assignment();\r\nASTNode *parse_expression();\r\nASTNode *parse_assignment_expression();\r\nASTNode *parse_comma_expression();\r\nASTNode *parse_additive_expression();\r\nASTNode *parse_additive_tail(ASTNode *left);\r\nASTNode *parse_term();\r\nASTNode *parse_term_tail(ASTNode *left);\r\nASTNode *parse_factor();\r\nASTNode *parse_postfix_expression();\r\n\r\n// Semantic  Analysis Function Prototypes\r\nvoid init_symbol_table();\r\nSymbol *lookup_symbol(const char *name);\r\nSymbol *insert_symbol(const char *name, DataType type, int line);\r\nvoid print_symbol_table();\r\nvoid free_symbol_table();\r\nint get_type_size(DataType type);\r\nDataType get_type_from_token(Token token);\r\nvoid semantic_analysis(ASTNode *node);\r\nvoid check_declaration(ASTNode *node);\r\nvoid check_assignment(ASTNode *node);\r\nvoid check_expression(ASTNode *node);\r\nDataType get_expression_type(ASTNode *node);\r\nvoid check_unary_operation(ASTNode *node);\r\n\r\n// Parse and Semantic Error Handling Function Prototypes\r\nvoid print_errors();\r\nvoid clear_errors();\r\n\r\n// TAC Generation Function Prototypes\r\nTACNode *generate_tac(ASTNode *ast);\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2);\r\nvoid print_tac(TACNode *tac);\r\nvoid free_tac(TACNode *tac);\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail);\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail);\r\n\r\nchar *get_temp_register();\r\nvoid free_temp_register(char *reg_name);\r\n\r\nvoid record_error(int line, const char *message);\r\nvoid reset_temp_registers();\r\n\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail);\r\n\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate);\r\nint get_var_memory_address(char *var_name);\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr);\r\nvoid free_mips_instructions(MIPSInstruction *head);\r\nbool is_register(char *name);\r\nMIPSInstruction *generate_assembly_code(TACNode *tac);\r\nconst char *get_mips_mnemonic(MIPSInstructionType type);\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename);\r\nchar *get_register_binary(char *reg_name);\r\nvoid decimal_to_binary(int n, char *binary_str, int bits);\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex);\r\n\r\n/* --------------------- MAIN FUNCTION --------------------- */\r\nint main(int argc, char *argv[])\r\n{\r\n    const char *fname = \"test.txt\";\r\n    if (argc > 1)\r\n        fname = argv[1];\r\n\r\n    process_file((char *)fname);\r\n    return 0;\r\n}\r\n\r\n/**\r\n * record_error:\r\n * Records an error message with the associated line number.\r\n * Parameters:\r\n * - line: the line number where the error occurred\r\n * - message: the descriptive error message\r\n * Returns: void\r\n */\r\nvoid record_error(int line, const char *message)\r\n{\r\n    ErrorInfo *new_error = malloc(sizeof(ErrorInfo)); // Allocate memory for new error\r\n    if (!new_error)                                   // Check for allocation failure\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for error info\\n\");\r\n        return;\r\n    }\r\n\r\n    new_error->line = line;                                               // Set line number\r\n    strncpy(new_error->message, message, sizeof(new_error->message) - 1); // Copy error message\r\n    new_error->message[sizeof(new_error->message) - 1] = '\\0';            // Ensure null-termination\r\n    new_error->next = NULL;                                               // Initialize next pointer\r\n\r\n    if (error_list == NULL) // If error list is empty, set new error as head\r\n    {\r\n        error_list = new_error;\r\n    }\r\n    else // Otherwise, append to the end of the list\r\n    {\r\n        ErrorInfo *current = error_list;\r\n        while (current->next != NULL)\r\n        {\r\n            current = current->next;\r\n        }\r\n        current->next = new_error;\r\n    }\r\n\r\n    error_count++;\r\n}\r\n\r\n/**\r\n * print_errors:\r\n * Prints all recorded errors to the standard output.\r\n * Returns: void\r\n */\r\nvoid print_errors()\r\n{\r\n    if (error_count == 0)\r\n    {\r\n        printf(\"No errors found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n------------------ ERRORS (%d found) ------------------\\n\", error_count);\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Line %d: %s\\n\", current->line, current->message);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * clear_errors:\r\n * Frees all recorded errors from memory.\r\n * Returns: void\r\n */\r\nvoid clear_errors()\r\n{\r\n    ErrorInfo *current = error_list;\r\n    while (current != NULL)\r\n    {\r\n        ErrorInfo *next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    error_list = NULL;\r\n    error_count = 0;\r\n}\r\n\r\n/**\r\n * get_temp_register:\r\n * Allocates and returns a temporary register name (t0-t9) for TAC generation.\r\n * Returns:\r\n * - a pointer to the temporary register name string\r\n */\r\nchar *get_temp_register()\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (!temp_registers_used[i]) // Find an unused register\r\n        {\r\n            temp_registers_used[i] = 1; // Mark it as used\r\n            temp_counter++;             // Increment usage counter\r\n            return temp_reg_names[i];   // Return the register name\r\n        }\r\n    }\r\n    temp_registers_used[0] = 1; // If all are used, reuse t0\r\n    temp_counter++;             // Track usage\r\n    return temp_reg_names[0];   // Return t0\r\n}\r\n\r\n/**\r\n * free_temp_register:\r\n * Frees a previously allocated temporary register.\r\n * Parameters:\r\n * - reg_name: the name of the register to free\r\n * Returns: void\r\n */\r\nvoid free_temp_register(char *reg_name)\r\n{\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        if (strcmp(temp_reg_names[i], reg_name) == 0) // Find the register\r\n        {\r\n            temp_registers_used[i] = 0; // Mark it as free\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * reset_temp_registers:\r\n * Resets all temporary registers to unused state.\r\n * Returns: void\r\n */\r\nvoid reset_temp_registers()\r\n{\r\n    for (int i = 0; i < 10; i++) // Loop over the registers and free all\r\n    {\r\n        temp_registers_used[i] = 0;\r\n    }\r\n    temp_counter = 0;\r\n}\r\n\r\n/**\r\n * init_symbol_table:\r\n * Initializes the symbol table by freeing any existing entries and resetting counters.\r\n * Returns: void\r\n */\r\nvoid init_symbol_table()\r\n{\r\n    free_symbol_table();       // Clear existing table\r\n    symbol_table = NULL;       // Reset head pointer\r\n    current_memory_offset = 0; // Reset memory offset\r\n    semantic_errors = 0;       // Reset semantic error count\r\n}\r\n\r\n/**\r\n * get_type_size:\r\n * Returns the size in bytes of the given data type.\r\n * Parameters:\r\n * - type: the data type (DataType enum)\r\n * Returns:\r\n * - size in bytes of the data type\r\n */\r\nint get_type_size(DataType type)\r\n{\r\n    switch (type) // Return size based on data type\r\n    {\r\n    case TYPE_INT: // Lets assume int is 4 bytes for MIPS64\r\n        return 4;\r\n    case TYPE_CHAR: // Char is 1 byte\r\n        return 1;\r\n    default:\r\n        return 8; // Let's default to 8 bytes for unknown types\r\n    }\r\n}\r\n\r\n/**\r\n * get_type_from_token:\r\n * Returns the DataType corresponding to a given token.\r\n * Parameters:\r\n * - token: the token to evaluate\r\n * Returns:\r\n * - the corresponding DataType enum value\r\n */\r\nDataType get_type_from_token(Token token)\r\n{\r\n    if (token.type == TOK_INT) // Map TOK_INT to TYPE_INT\r\n        return TYPE_INT;\r\n    if (token.type == TOK_CHAR) // Map TOK_CHAR to TYPE_CHAR\r\n        return TYPE_CHAR;\r\n    return TYPE_UNKNOWN; // Default to TYPE_UNKNOWN for other tokens\r\n}\r\n\r\n/**\r\n * lookup_symbol:\r\n * Looks up a symbol by name in the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol to look up\r\n * Returns:\r\n * - pointer to the Symbol if found, NULL otherwise\r\n */\r\nSymbol *lookup_symbol(const char *name)\r\n{\r\n    Symbol *current = symbol_table; // Start at the head of the symbol table\r\n    while (current != NULL)         // Traverse the linked list\r\n    {\r\n        if (strcmp(current->name, name) == 0) // Check for matching name\r\n        {\r\n            return current; // If found return the found symbol\r\n        }\r\n        current = current->next; // Else move to the next symbol\r\n    }\r\n    return NULL; // Not found, return NULL\r\n}\r\n\r\n/**\r\n * insert_symbol:\r\n * Inserts a new symbol into the symbol table.\r\n * Parameters:\r\n * - name: the name of the symbol\r\n * - type: the data type of the symbol\r\n * - line: the line number where the symbol is declared\r\n * Returns:\r\n * - pointer to the newly inserted Symbol, or existing Symbol if redeclared\r\n * on redeclaration\r\n *\r\n */\r\nSymbol *insert_symbol(const char *name, DataType type, int line)\r\n{\r\n    Symbol *existing = lookup_symbol(name); // Check for existing symbol\r\n    if (existing != NULL)                   // If the identifier is existing in the symbol table and is redeclared then send error\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Redeclaration of variable '%s' (previously declared at line %d)\",\r\n                 name, existing->line);\r\n        record_error(line, error_msg);\r\n        semantic_errors++;\r\n        return existing;\r\n    }\r\n\r\n    Symbol *new_symbol = malloc(sizeof(Symbol)); // Create new symbol entry if identifier does not exist in the symbo table\r\n    if (!new_symbol)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->name = strdup(name);\r\n    if (!new_symbol->name)\r\n    {\r\n        free(new_symbol);\r\n        fprintf(stderr, \"Error: Failed to allocate memory for symbol name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    new_symbol->type = type;\r\n    new_symbol->declared = 1;\r\n    new_symbol->line = line;\r\n\r\n    int type_size = get_type_size(type);\r\n\r\n    if (current_memory_offset % 8 != 0) // Memory Offset is 8 bytes based on MIPS64 memory offsets\r\n    {\r\n        current_memory_offset += 8 - (current_memory_offset % 8);\r\n    }\r\n    new_symbol->memory_offset = current_memory_offset;\r\n    current_memory_offset += type_size;\r\n\r\n    new_symbol->next = symbol_table;\r\n    symbol_table = new_symbol;\r\n\r\n    return new_symbol;\r\n}\r\n\r\n/**\r\n * print_symbol_table:\r\n * For Prints the Symbol Table For Debugging\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_symbol_table()\r\n{\r\n    printf(\"\\n===== SYMBOL TABLE =====\\n\");\r\n    printf(\"%-20s %-10s %-8s %-10s %s\\n\",\r\n           \"Name\", \"Type\", \"Line\", \"Offset\", \"Size\");\r\n    printf(\"------------------------------------------------------------\\n\");\r\n\r\n    Symbol *current = symbol_table;\r\n    int total_memory = 0;\r\n\r\n    while (current != NULL)\r\n    {\r\n        const char *type_str = (current->type == TYPE_INT) ? \"int\" : (current->type == TYPE_CHAR) ? \"char\"\r\n                                                                                                  : \"unknown\";\r\n        int size = get_type_size(current->type);\r\n        printf(\"%-20s %-10s %-8d %-10d %d bytes\\n\",\r\n               current->name, type_str, current->line,\r\n               current->memory_offset, size);\r\n        total_memory += size;\r\n        current = current->next;\r\n    }\r\n\r\n    printf(\"------------------------------------------------------------\\n\");\r\n    printf(\"Total memory allocated: %d bytes\\n\", current_memory_offset);\r\n    printf(\"Variables count: \");\r\n\r\n    int count = 0;\r\n    current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n    printf(\"%d\\n\", count);\r\n}\r\n\r\n/**\r\n * free_symbol_table:\r\n * Free memory allocated for the symbol table\r\n * Return:\r\n * - void\r\n */\r\nvoid free_symbol_table()\r\n{\r\n    Symbol *current = symbol_table;\r\n    while (current != NULL)\r\n    {\r\n        Symbol *next = current->next;\r\n        free(current->name);\r\n        free(current);\r\n        current = next;\r\n    }\r\n    symbol_table = NULL;\r\n}\r\n\r\n/**\r\n * semantic_analysis:\r\n * Perform semantic analysis on an abstract syntax tree (AST).\r\n *\r\n * This function recursively traverses the AST and performs semantic checks\r\n * on each node, including:\r\n *  - Variable declarations: ensures variables are properly declared.\r\n *  - Assignments: verifies type and declaration validity.\r\n *  - Identifiers: checks that all variables used are declared.\r\n *  - Binary operations: verifies operand compatibility and type correctness.\r\n *\r\n * Any semantic errors (e.g., use of undeclared variables, invalid types)\r\n * are recorded via `record_error()` and counted in the global\r\n * `semantic_errors` variable.\r\n *\r\n * @param Pointer to the current AST node being analyzed.\r\n *\r\n */\r\nvoid semantic_analysis(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_VAR_DECL:\r\n        check_declaration(node);\r\n        break;\r\n    case NODE_ASSIGN:\r\n        check_assignment(node);\r\n        break;\r\n    case NODE_IDENT:\r\n        if (lookup_symbol(node->token.value) == NULL)\r\n        {\r\n            char error_msg[256];\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Undeclared variable '%s'\", node->token.value);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n        break;\r\n    case NODE_BIN_OP:\r\n        check_expression(node);\r\n        break;\r\n    case NODE_UNARY_OP:\r\n        check_unary_operation(node);\r\n        break;\r\n    case NODE_COMMA_EXPR:\r\n        semantic_analysis(node->left);\r\n        semantic_analysis(node->right);\r\n        return;\r\n    }\r\n\r\n    semantic_analysis(node->left);\r\n    semantic_analysis(node->right);\r\n}\r\n\r\nvoid check_unary_operation(ASTNode *node)\r\n{\r\n    if (node->type != NODE_UNARY_OP || node->left == NULL)\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires a variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value);\r\n    if (symbol == NULL)\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Undeclared variable '%s' in increment/decrement\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    // Only int and char types can be incremented/decremented\r\n    if (symbol->type != TYPE_INT && symbol->type != TYPE_CHAR)\r\n    {\r\n        record_error(node->token.line, \"Increment/decrement requires numeric type\");\r\n        semantic_errors++;\r\n    }\r\n}\r\n\r\n/**\r\n * check_declaration:\r\n * Perform semantic validation of a variable declaration node.\r\n * This function ensures that each variable declaration in the AST is\r\n * semantically correct. It checks:\r\n * - That the declared type is valid (not unknown).\r\n * - That the variable is properly inserted into the symbol table.\r\n * - That any initialization expression is type-compatible with the declared type.\r\n *\r\n */\r\nvoid check_declaration(ASTNode *node)\r\n{\r\n    // Check if the Node type is correct and that the left side of the node is not null\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return;\r\n\r\n    DataType var_type = get_type_from_token(node->token);\r\n\r\n    if (var_type == TYPE_UNKNOWN)\r\n    {\r\n        record_error(node->token.line, \"Unknown type in declaration\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = insert_symbol(node->left->token.value, var_type, node->left->token.line); // Insert symbol based on the declaration node type\r\n\r\n    if (node->right != NULL)\r\n    {\r\n        DataType expr_type = get_expression_type(node->right);\r\n        if (expr_type != TYPE_ERROR && expr_type != var_type)\r\n        {\r\n            if (!(var_type == TYPE_CHAR && expr_type == TYPE_INT || var_type == TYPE_INT && expr_type == TYPE_CHAR))\r\n            {\r\n                char error_msg[256];\r\n                const char *expected_type = (var_type == TYPE_INT) ? \"int\" : \"char\";\r\n                const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n                snprintf(error_msg, sizeof(error_msg),\r\n                         \"Type mismatch in initialization: expected %s, got %s\",\r\n                         expected_type, actual_type);\r\n                record_error(node->right->token.line, error_msg);\r\n                semantic_errors++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_assignment :\r\n * Perform semantic checks for assignment statements.\r\n *\r\n * This function validates the semantics of assignment expressions in the AST.\r\n * It ensures that:\r\n *  - The left-hand side (LHS) of an assignment is a valid variable (identifier).\r\n *  - The variable being assigned to has been declared in the symbol table.\r\n *  - The assigned expression is type-compatible with the variable's declared type.\r\n *\r\n * Type compatibility follows relaxed C-style semantics:\r\n *  - Assignments between `int` and `char` are allowed implicitly.\r\n *  - Mismatched or undeclared types are reported as semantic errors.\r\n *\r\n */\r\nvoid check_assignment(ASTNode *node)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL) // Check if the node meets the assignment rule / format\r\n        return;\r\n\r\n    if (node->left->type != NODE_IDENT) // Check if the left node of the assignment node is of type identifier\r\n    {\r\n        record_error(node->token.line, \"Assignment to non-variable\");\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    Symbol *symbol = lookup_symbol(node->left->token.value); // Look up if the identifier is already declared in the symbol table\r\n    if (symbol == NULL)                                      // If it is not assigned , then send error for using undeclared variable\r\n    {\r\n        char error_msg[256];\r\n        snprintf(error_msg, sizeof(error_msg),\r\n                 \"Assignment to undeclared variable '%s'\",\r\n                 node->left->token.value);\r\n        record_error(node->left->token.line, error_msg);\r\n        semantic_errors++;\r\n        return;\r\n    }\r\n\r\n    DataType expr_type = get_expression_type(node->right); // Infer the datatype of the expression of the right node.\r\n    if (expr_type != TYPE_ERROR && expr_type != symbol->type)\r\n    {\r\n        if (!((symbol->type == TYPE_INT && expr_type == TYPE_CHAR) ||\r\n              (symbol->type == TYPE_CHAR && expr_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *expected_type = (symbol->type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *actual_type = (expr_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in assignment to '%s': expected %s, got %s\",\r\n                     symbol->name, expected_type, actual_type);\r\n            record_error(node->right->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * check_expression:\r\n * Perform semantic checks for binary expressions.\r\n *\r\n * This function validates binary operations (e.g., +, -, *, /, etc.) in the AST.\r\n * It ensures that:\r\n *  - Both operands are semantically valid and have resolvable data types.\r\n *  - The operand types are compatible for arithmetic operations.\r\n *  - Type mismatches are detected and reported unless compatible (e.g., int ↔ char).\r\n *\r\n */\r\nvoid check_expression(ASTNode *node)\r\n{\r\n    if (node->type != NODE_BIN_OP)\r\n        return;\r\n\r\n    DataType left_type = get_expression_type(node->left);   // Get type of left node\r\n    DataType right_type = get_expression_type(node->right); // Get type of right node\r\n\r\n    if (node->token.type == TOK_DIV)\r\n    {\r\n        if (node->right->type == NODE_NUMBER && strcmp(node->right->token.value, \"0\") == 0)\r\n        {\r\n            record_error(node->token.line, \"Division by zero in constant expression\");\r\n            semantic_errors++;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (left_type != TYPE_ERROR && right_type != TYPE_ERROR && left_type != right_type)\r\n    {\r\n        if (!((left_type == TYPE_INT && right_type == TYPE_CHAR) ||\r\n              (left_type == TYPE_CHAR && right_type == TYPE_INT)))\r\n        {\r\n            char error_msg[256];\r\n            const char *left_str = (left_type == TYPE_INT) ? \"int\" : \"char\";\r\n            const char *right_str = (right_type == TYPE_INT) ? \"int\" : \"char\";\r\n            snprintf(error_msg, sizeof(error_msg),\r\n                     \"Type mismatch in expression: %s and %s\",\r\n                     left_str, right_str);\r\n            record_error(node->token.line, error_msg);\r\n            semantic_errors++;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get_expresion_type:\r\n * Determine the resulting data type of an expression node.\r\n *\r\n * This function performs type inference on an expression subtree within the AST.\r\n * It recursively analyzes identifiers, literals, and binary operations to deduce\r\n * the resulting `DataType` (e.g., `TYPE_INT`, `TYPE_CHAR`).\r\n *\r\n * The logic reflects standard C type promotion rules:\r\n *  - Any expression containing an `int` operand yields an `int` result.\r\n *  - `char` + `char` yields `char`.\r\n *  - Undeclared identifiers or structurally invalid expressions return `TYPE_ERROR`.\r\n */\r\nDataType get_expression_type(ASTNode *node)\r\n{\r\n    if (node == NULL)\r\n        return TYPE_ERROR;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        Symbol *symbol = lookup_symbol(node->token.value);\r\n        if (symbol == NULL)\r\n        {\r\n            return TYPE_ERROR;\r\n        }\r\n        return symbol->type;\r\n    }\r\n    case NODE_NUMBER:\r\n        return TYPE_INT;\r\n    case NODE_CHAR_LITERAL:\r\n        return TYPE_CHAR;\r\n    case NODE_BIN_OP:\r\n    {\r\n        DataType left_type = get_expression_type(node->left);\r\n        DataType right_type = get_expression_type(node->right);\r\n\r\n        if (left_type == TYPE_INT || right_type == TYPE_INT)\r\n        {\r\n            return TYPE_INT;\r\n        }\r\n        if (left_type == TYPE_CHAR && right_type == TYPE_CHAR)\r\n        {\r\n            return TYPE_CHAR;\r\n        }\r\n        return TYPE_ERROR;\r\n    }\r\n    case NODE_UNARY_OP:\r\n        return get_expression_type(node->left);\r\n    case NODE_ASSIGN:\r\n        return get_expression_type(node->left);\r\n    case NODE_COMMA_EXPR:\r\n        return get_expression_type(node->right);\r\n    default:\r\n        return TYPE_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * create_tac_node :\r\n * Create new node in the TAC list\r\n * Parameters:\r\n * - type - type of TACNode\r\n * - result - the left hand side of the statement\r\n * - arg1 - the first argument after the assignment\r\n * - arg2 - the second argument after the assignment\r\n */\r\nTACNode *create_tac_node(TACType type, const char *result, const char *arg1, const char *arg2)\r\n{\r\n    TACNode *node = malloc(sizeof(TACNode));\r\n    if (!node)\r\n        return NULL;\r\n\r\n    node->type = type;\r\n    node->result = result ? strdup(result) : NULL;\r\n    node->arg1 = arg1 ? strdup(arg1) : NULL;\r\n    node->arg2 = arg2 ? strdup(arg2) : NULL;\r\n    node->prev = NULL;\r\n    node->next = NULL;\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * print_tac:\r\n * For Debugging , prints the Whole Three Address Code\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid print_tac(TACNode *tac)\r\n{\r\n    printf(\"\\n===== THREE ADDRESS CODE =====\\n\");\r\n\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_ADD:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_SUB:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_MUL:\r\n            printf(\"%s = %s * %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DIV:\r\n            printf(\"%s = %s / %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_COPY:\r\n            printf(\"%s = %s\\n\", current->result, current->arg1);\r\n            break;\r\n        case TAC_INC:\r\n            printf(\"%s = %s + %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        case TAC_DEC:\r\n            printf(\"%s = %s - %s\\n\", current->result, current->arg1, current->arg2);\r\n            break;\r\n        default:\r\n            printf(\"Unknown TAC instruction\\n\");\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * free_tac:\r\n * Free all he TAC nodes in the linked list\r\n * Parameters:\r\n * - tac - head of the TAC linked list\r\n * Returns:\r\n * - void\r\n */\r\nvoid free_tac(TACNode *tac)\r\n{\r\n    TACNode *current = tac;\r\n    while (current != NULL)\r\n    {\r\n        TACNode *next = current->next;\r\n        if (current->result)\r\n            free(current->result);\r\n        if (current->arg1)\r\n            free(current->arg1);\r\n        if (current->arg2)\r\n            free(current->arg2);\r\n        free(current);\r\n        current = next;\r\n    }\r\n}\r\n\r\nTACNode *generate_tac_expr(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node == NULL)\r\n        return NULL;\r\n\r\n    switch (node->type)\r\n    {\r\n    case NODE_IDENT:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_COPY, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_NUMBER:\r\n    case NODE_CHAR_LITERAL:\r\n    {\r\n        char *temp = get_temp_register();\r\n        TACNode *tac = create_tac_node(TAC_ASSIGN, temp, node->token.value, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_BIN_OP:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n        char *left_temp = left_tac ? left_tac->result : NULL;\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n        char *right_temp = right_tac ? right_tac->result : NULL;\r\n\r\n        if (!left_temp || !right_temp)\r\n            return NULL;\r\n\r\n        char *result_temp = get_temp_register();\r\n        TACType op_type;\r\n\r\n        switch (node->token.type)\r\n        {\r\n        case TOK_PLUS:\r\n            op_type = TAC_ADD;\r\n            break;\r\n        case TOK_MINUS:\r\n            op_type = TAC_SUB;\r\n            break;\r\n        case TOK_MULT:\r\n            op_type = TAC_MUL;\r\n            break;\r\n        case TOK_DIV:\r\n            op_type = TAC_DIV;\r\n            break;\r\n        default:\r\n            return NULL;\r\n        }\r\n\r\n        TACNode *tac = create_tac_node(op_type, result_temp, left_temp, right_temp);\r\n\r\n        free_temp_register(left_temp);\r\n        free_temp_register(right_temp);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = tac;\r\n            tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = tac;\r\n        return tac;\r\n    }\r\n\r\n    case NODE_ASSIGN:\r\n    {\r\n        TACNode *rhs_tac = generate_tac_expr(node->right, tac_tail);\r\n        if (!rhs_tac)\r\n            return NULL;\r\n\r\n        char *lhs_name = node->left->token.value;\r\n        TACNode *assign_tac = create_tac_node(TAC_COPY, lhs_name, rhs_tac->result, NULL);\r\n\r\n        if (*tac_tail)\r\n        {\r\n            (*tac_tail)->next = assign_tac;\r\n            assign_tac->prev = *tac_tail;\r\n        }\r\n        *tac_tail = assign_tac;\r\n\r\n        return rhs_tac;\r\n    }\r\n\r\n    case NODE_COMMA_EXPR:\r\n    {\r\n        TACNode *left_tac = generate_tac_expr(node->left, tac_tail);\r\n\r\n        if (left_tac && left_tac->result && is_register(left_tac->result))\r\n        {\r\n            free_temp_register(left_tac->result);\r\n        }\r\n\r\n        TACNode *right_tac = generate_tac_expr(node->right, tac_tail);\r\n\r\n        return right_tac;\r\n    }\r\n\r\n    case NODE_UNARY_OP:\r\n    {\r\n        if (node->token.type == TOK_INCREMENT || node->token.type == TOK_DECREMENT)\r\n        {\r\n            if (node->left == NULL || node->left->type != NODE_IDENT)\r\n                return NULL;\r\n\r\n            char *var_name = node->left->token.value;\r\n            char *temp = get_temp_register();\r\n\r\n            TACNode *load_tac = create_tac_node(TAC_COPY, temp, var_name, NULL);\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = load_tac;\r\n                load_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = load_tac;\r\n\r\n            TACType op_type = (node->token.type == TOK_INCREMENT) ? TAC_INC : TAC_DEC;\r\n            TACNode *op_tac = create_tac_node(op_type, var_name, var_name, \"1\");\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = op_tac;\r\n                op_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = op_tac;\r\n\r\n            return load_tac;\r\n        }\r\n\r\n        return NULL;\r\n    }\r\n\r\n    default:\r\n        return NULL;\r\n    }\r\n}\r\n/**\r\n * generate_tac_decl:\r\n * Generates TAC for variable declaration\r\n * Parameters :\r\n * - node - Head of the AST Linked List\r\n * - tac_tail : the last entry in the TAC linked list\r\n * Returns:\r\n * - TACNode\r\n */\r\nTACNode *generate_tac_decl(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_VAR_DECL || node->left == NULL)\r\n        return NULL;\r\n\r\n    char *var_name = node->left->token.value; // get the variable name from token of left node\r\n\r\n    if (node->right != NULL) // Check if the right node is not null meaning that it has assignment\r\n    {\r\n\r\n        TACNode *expr_tac = generate_tac_expr(node->right, tac_tail); // Perform TAC Generation for Expressions\r\n        if (expr_tac)\r\n        {\r\n            TACNode *assign_tac = create_tac_node(TAC_COPY, var_name, expr_tac->result, NULL);\r\n\r\n            free_temp_register(expr_tac->result);\r\n\r\n            if (*tac_tail)\r\n            {\r\n                (*tac_tail)->next = assign_tac;\r\n                assign_tac->prev = *tac_tail;\r\n            }\r\n            *tac_tail = assign_tac;\r\n            return assign_tac;\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * generate_tac_assign:\r\n * Generate TAC for Assignment TAC type\r\n */\r\nTACNode *generate_tac_assign(ASTNode *node, TACNode **tac_tail)\r\n{\r\n    if (node->type != NODE_ASSIGN || node->left == NULL || node->right == NULL)\r\n        return NULL;\r\n\r\n    TACNode *expr_tac = generate_tac_expr(node, tac_tail);\r\n\r\n    if (expr_tac && expr_tac->result)\r\n    {\r\n        free_temp_register(expr_tac->result);\r\n    }\r\n\r\n    return expr_tac;\r\n}\r\n// this function process the statement list recursively and generate TAC for each statement\r\nvoid process_stmt_list(ASTNode *stmt_list, TACNode **tac_tail)\r\n{\r\n    if (stmt_list == NULL)\r\n        return;\r\n\r\n    if (stmt_list->left != NULL)\r\n    {\r\n        ASTNode *stmt = stmt_list->left;\r\n\r\n        switch (stmt->type)\r\n        {\r\n        case NODE_VAR_DECL:\r\n            generate_tac_decl(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_ASSIGN:\r\n            generate_tac_assign(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_UNARY_OP:\r\n            generate_tac_expr(stmt, tac_tail);\r\n            break;\r\n\r\n        case NODE_DECL_LIST:\r\n        {\r\n            ASTNode *decl = stmt;\r\n            while (decl != NULL)\r\n            {\r\n                if (decl->type == NODE_VAR_DECL)\r\n                {\r\n                    generate_tac_decl(decl, tac_tail);\r\n                }\r\n                else if (decl->type == NODE_DECL_LIST && decl->left != NULL)\r\n                {\r\n                    generate_tac_decl(decl->left, tac_tail);\r\n                }\r\n                decl = decl->right;\r\n            }\r\n            break;\r\n        }\r\n        }\r\n    }\r\n\r\n    if (stmt_list->right != NULL)\r\n    {\r\n        process_stmt_list(stmt_list->right, tac_tail);\r\n    }\r\n}\r\n// generate_tac\r\nTACNode *generate_tac(ASTNode *ast)\r\n{\r\n    if (ast == NULL)\r\n        return NULL;\r\n\r\n    TACNode *tac_head = NULL;\r\n    TACNode *tac_tail = NULL;\r\n\r\n    reset_temp_registers();\r\n\r\n    if (ast->type == NODE_PROGRAM && ast->left != NULL)\r\n    {\r\n        process_stmt_list(ast->left, &tac_tail);\r\n    }\r\n    else\r\n    {\r\n\r\n        process_stmt_list(ast, &tac_tail);\r\n    }\r\n\r\n    if (tac_tail != NULL)\r\n    {\r\n        tac_head = tac_tail;\r\n        while (tac_head->prev != NULL)\r\n        {\r\n            tac_head = tac_head->prev;\r\n        }\r\n    }\r\n\r\n    return tac_head;\r\n}\r\n\r\n/**\r\n * create_mips_instruction\r\n * Initializes a MIPSInstruction Struct\r\n */\r\nMIPSInstruction *create_mips_instruction(MIPSInstructionType type, const char *rt, const char *rs, const char *rd, const char *base, const char *offset, const char *immediate)\r\n{\r\n    MIPSInstruction *instr = malloc(sizeof(MIPSInstruction));\r\n    if (!instr)\r\n        return NULL;\r\n\r\n    instr->type = type;\r\n    instr->rt = rt ? strdup(rt) : NULL;\r\n    instr->rs = rs ? strdup(rs) : NULL;\r\n    instr->rd = rd ? strdup(rd) : NULL;\r\n    instr->base = base ? strdup(base) : NULL;\r\n    instr->offset = offset ? strdup(offset) : NULL;\r\n    instr->immediate = immediate ? strdup(immediate) : NULL;\r\n    instr->prev = NULL;\r\n    instr->next = NULL;\r\n\r\n    return instr;\r\n}\r\n\r\n/**\r\n * get_var_memory_address:\r\n * Lookup for a varaible memory address in symbol table\r\n */\r\nint get_var_memory_address(char *var_name)\r\n{\r\n    Symbol *symbol = lookup_symbol(var_name);\r\n    if (symbol != NULL)\r\n    {\r\n        return symbol->memory_offset;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * append_mips_instruction:\r\n * Append MIPSInstuction node to the linked list\r\n */\r\nvoid append_mips_instruction(MIPSInstruction **head, MIPSInstruction **tail, MIPSInstruction *new_instr)\r\n{\r\n    if (*head == NULL)\r\n    {\r\n        *head = *tail = new_instr;\r\n    }\r\n    else\r\n    {\r\n        (*tail)->next = new_instr;\r\n        new_instr->prev = *tail;\r\n        *tail = new_instr;\r\n    }\r\n}\r\n\r\n/**\r\n * Free the mips instructions linked list\r\n */\r\nvoid free_mips_instructions(MIPSInstruction *head)\r\n{\r\n    MIPSInstruction *temp;\r\n    while (head)\r\n    {\r\n        temp = head;\r\n        head = head->next;\r\n\r\n        free(temp->rt);\r\n        free(temp->rs);\r\n        free(temp->rd);\r\n        free(temp->base);\r\n        free(temp->offset);\r\n        free(temp->immediate);\r\n        free(temp);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the current identifier   in the TAC is a register\r\n */\r\nbool is_register(char *name)\r\n{\r\n    if (strcmp(name, \"t0\") == 0 || strcmp(name, \"t1\") == 0 || strcmp(name, \"t2\") == 0 ||\r\n        strcmp(name, \"t3\") == 0 || strcmp(name, \"t4\") == 0 || strcmp(name, \"t5\") == 0 ||\r\n        strcmp(name, \"t6\") == 0 || strcmp(name, \"t7\") == 0 || strcmp(name, \"t8\") == 0 ||\r\n        strcmp(name, \"t9\") == 0)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n\r\n/**\r\n * Generate Assembly Code\r\n */\r\nMIPSInstruction *generate_assembly_code(TACNode *tac)\r\n{\r\n    if (tac == NULL)\r\n    {\r\n        printf(\"No TAC generated\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    TACNode *current = tac;\r\n    MIPSInstruction *head = NULL;\r\n    MIPSInstruction *tail = NULL;\r\n\r\n    while (current != NULL)\r\n    {\r\n        MIPSInstruction *instr = NULL;\r\n\r\n        switch (current->type)\r\n        {\r\n        case TAC_ASSIGN:\r\n            if (isalpha(current->arg1[0]) || (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0'))\r\n            {\r\n                char imm_str[12];\r\n                int char_value;\r\n\r\n                if (current->arg1[0] == '\\\\' && current->arg1[1] != '\\0')\r\n                {\r\n                    switch (current->arg1[1])\r\n                    {\r\n                    case 'n':\r\n                        char_value = '\\n';\r\n                        break;\r\n                    case 't':\r\n                        char_value = '\\t';\r\n                        break;\r\n                    case 'r':\r\n                        char_value = '\\r';\r\n                        break;\r\n                    case '0':\r\n                        char_value = '\\0';\r\n                        break;\r\n                    case '\\\\':\r\n                        char_value = '\\\\';\r\n                        break;\r\n                    case '\\'':\r\n                        char_value = '\\'';\r\n                        break;\r\n                    case '\\\"':\r\n                        char_value = '\\\"';\r\n                        break;\r\n                    case 'a':\r\n                        char_value = '\\a';\r\n                        break;\r\n                    case 'b':\r\n                        char_value = '\\b';\r\n                        break;\r\n                    case 'f':\r\n                        char_value = '\\f';\r\n                        break;\r\n                    case 'v':\r\n                        char_value = '\\v';\r\n                        break;\r\n                    default:\r\n                        char_value = current->arg1[1];\r\n                        break;\r\n                    }\r\n                    sprintf(imm_str, \"%d\", char_value);\r\n                }\r\n                else\r\n                {\r\n                    sprintf(imm_str, \"%d\", (int)current->arg1[0]);\r\n                }\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, imm_str);\r\n            }\r\n            else\r\n            {\r\n                instr = create_mips_instruction(MIPS_DADDIU, current->result, \"zero\", NULL, NULL, NULL, current->arg1);\r\n            }\r\n            break;\r\n\r\n        case TAC_INC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n            MIPSInstruction *add = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"1\");\r\n            append_mips_instruction(&head, &tail, add);\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_DEC:\r\n        {\r\n            char offset_str[12];\r\n            sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n\r\n            char *temp_reg = get_temp_register();\r\n            MIPSInstruction *load = create_mips_instruction(\r\n                MIPS_LD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n            append_mips_instruction(&head, &tail, load);\r\n\r\n            MIPSInstruction *sub = create_mips_instruction(\r\n                MIPS_DADDIU, temp_reg, temp_reg, NULL, NULL, NULL, \"-1\");\r\n            append_mips_instruction(&head, &tail, sub);\r\n\r\n            instr = create_mips_instruction(\r\n                MIPS_SD, temp_reg, NULL, NULL, \"zero\", offset_str, NULL);\r\n\r\n            free_temp_register(temp_reg);\r\n        }\r\n        break;\r\n\r\n        case TAC_COPY:\r\n        {\r\n            char offset_str[12];\r\n\r\n            if (is_register(current->arg1))\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->result));\r\n                instr = create_mips_instruction(\r\n                    MIPS_SD,\r\n                    current->arg1,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n            else\r\n            {\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                instr = create_mips_instruction(\r\n                    MIPS_LD,\r\n                    current->result,\r\n                    NULL, NULL,\r\n                    \"zero\",\r\n                    offset_str,\r\n                    NULL);\r\n            }\r\n        }\r\n        break;\r\n\r\n        case TAC_ADD:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DADDU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_SUB:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            instr = create_mips_instruction(MIPS_DSUBU, reg2, reg1, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_MUL:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *mult = create_mips_instruction(MIPS_DMULT, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, mult);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        case TAC_DIV:\r\n        {\r\n            char *reg1 = current->arg1;\r\n            char *reg2 = current->arg2;\r\n            bool free_reg1 = false;\r\n            bool free_reg2 = false;\r\n\r\n            if (!is_register(current->arg1))\r\n            {\r\n                reg1 = get_temp_register();\r\n                free_reg1 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg1));\r\n                MIPSInstruction *load1 = create_mips_instruction(\r\n                    MIPS_LD, reg1, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load1);\r\n            }\r\n\r\n            if (!is_register(current->arg2))\r\n            {\r\n                reg2 = get_temp_register();\r\n                free_reg2 = true;\r\n                char offset_str[12];\r\n                sprintf(offset_str, \"%d\", get_var_memory_address(current->arg2));\r\n                MIPSInstruction *load2 = create_mips_instruction(\r\n                    MIPS_LD, reg2, NULL, NULL, \"zero\", offset_str, NULL);\r\n                append_mips_instruction(&head, &tail, load2);\r\n            }\r\n\r\n            MIPSInstruction *div = create_mips_instruction(MIPS_DDIV, reg2, reg1, NULL, NULL, NULL, NULL);\r\n            append_mips_instruction(&head, &tail, div);\r\n            instr = create_mips_instruction(MIPS_MFLO, NULL, NULL, current->result, NULL, NULL, NULL);\r\n\r\n            if (free_reg1)\r\n                free_temp_register(reg1);\r\n            if (free_reg2)\r\n                free_temp_register(reg2);\r\n        }\r\n        break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n\r\n        if (instr != NULL)\r\n        {\r\n            append_mips_instruction(&head, &tail, instr);\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/**\r\n * Dictionary for MIPSInstructionType Enum\r\n */\r\nconst char *get_mips_mnemonic(MIPSInstructionType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case MIPS_DADDIU:\r\n        return \"daddiu\";\r\n    case MIPS_DADDU:\r\n        return \"daddu\";\r\n    case MIPS_DSUBU:\r\n        return \"dsubu\";\r\n    case MIPS_DMULT:\r\n        return \"dmult\";\r\n    case MIPS_DDIV:\r\n        return \"ddiv\";\r\n    case MIPS_MFLO:\r\n        return \"mflo\";\r\n    case MIPS_SD:\r\n        return \"sd\";\r\n    case MIPS_SB:\r\n        return \"sb\";\r\n    case MIPS_LD:\r\n        return \"ld\";\r\n    case MIPS_LB:\r\n        return \"lb\";\r\n    default:\r\n        return \"unknown\";\r\n    }\r\n}\r\n\r\n/**\r\n * Write assembly code into file\r\n */\r\nvoid write_assembly_to_file(MIPSInstruction *head, const char *filename)\r\n{\r\n    FILE *fp = fopen(filename, \"w\");\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    fprintf(fp, \".data\\n\\n.code\\n\\n\");\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        const char *mnemonic = get_mips_mnemonic(curr->type);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DSUBU:\r\n            fprintf(fp, \"%s $%s, $%s, $%s\\n\", mnemonic, curr->rd, curr->rs, curr->rt);\r\n            break;\r\n\r\n        case MIPS_DADDIU:\r\n            fprintf(fp, \"%s $%s, $%s, %s\\n\", mnemonic, curr->rt, curr->rs, curr->immediate);\r\n            break;\r\n\r\n        case MIPS_SD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_SB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LD:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_LB:\r\n            fprintf(fp, \"%s $%s, %s($%s)\\n\", mnemonic, curr->rt, curr->offset, curr->base);\r\n            break;\r\n        case MIPS_DMULT:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_DDIV:\r\n            fprintf(fp, \"%s $%s, $%s\\n\", mnemonic, curr->rs, curr->rt);\r\n            break;\r\n        case MIPS_MFLO:\r\n            fprintf(fp, \"%s $%s\\n\", mnemonic, curr->rd);\r\n            break;\r\n\r\n        default:\r\n            fprintf(fp, \"%s\\n\", mnemonic);\r\n            break;\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n    printf(\"MIPS assembly written to %s\\n\", filename);\r\n}\r\n\r\n/**\r\n * Dictionary for binary equivalent for registers\r\n */\r\nchar *get_register_binary(char *reg_name)\r\n{\r\n    if (strcmp(reg_name, \"zero\") == 0)\r\n        return \"00000\";\r\n    else if (strcmp(reg_name, \"t0\") == 0)\r\n        return \"01000\";\r\n    else if (strcmp(reg_name, \"t1\") == 0)\r\n        return \"01001\";\r\n    else if (strcmp(reg_name, \"t2\") == 0)\r\n        return \"01010\";\r\n    else if (strcmp(reg_name, \"t3\") == 0)\r\n        return \"01011\";\r\n    else if (strcmp(reg_name, \"t4\") == 0)\r\n        return \"01100\";\r\n    else if (strcmp(reg_name, \"t5\") == 0)\r\n        return \"01101\";\r\n    else if (strcmp(reg_name, \"t6\") == 0)\r\n        return \"01110\";\r\n    else if (strcmp(reg_name, \"t7\") == 0)\r\n        return \"01111\";\r\n    else if (strcmp(reg_name, \"t8\") == 0)\r\n        return \"11000\";\r\n    else if (strcmp(reg_name, \"t9\") == 0)\r\n        return \"11001\";\r\n    else\r\n        return \"00000\"; // Default to zero for unknown registers\r\n}\r\n\r\n/**\r\n * Helper function for converting decimal to binary\r\n */\r\nvoid decimal_to_binary(int n, char *binary_str, int bits)\r\n{\r\n    binary_str[bits] = '\\0';\r\n    for (int i = bits - 1; i >= 0; i--)\r\n    {\r\n        binary_str[i] = (n & 1) ? '1' : '0';\r\n        n >>= 1;\r\n    }\r\n}\r\n\r\n/**\r\n * write the machine code to file both binary and hex\r\n */\r\nvoid write_machine_code_to_file(MIPSInstruction *head, const char *filename_binary, const char *filename_hex)\r\n{\r\n    FILE *fp = fopen(filename_binary, \"w\");\r\n    FILE *fph = NULL;\r\n    if (strlen(filename_hex) > 0)\r\n    {\r\n        printf(\"Hex Output Set True\\n\");\r\n        fph = fopen(filename_hex, \"w\");\r\n        if (!fph)\r\n        {\r\n            perror(\"Error opening file for writing hex code\");\r\n            fclose(fp);\r\n            return;\r\n        }\r\n    }\r\n    if (!fp)\r\n    {\r\n        perror(\"Error opening file for writing assembly code\");\r\n        return;\r\n    }\r\n\r\n    MIPSInstruction *curr = head;\r\n    while (curr)\r\n    {\r\n        char *binary_rep = malloc(33);\r\n\r\n        switch (curr->type)\r\n        {\r\n        case MIPS_DADDU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101101\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DSUBU:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *sa = \"00000\";\r\n            char *funct = \"101111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s%s\", op_code, rd, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DADDIU:\r\n        {\r\n            char *op_code = \"011001\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char immediate[33];\r\n            decimal_to_binary(atoi(curr->immediate), immediate, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, rs, rt, immediate);\r\n            break;\r\n        }\r\n        case MIPS_SD:\r\n        {\r\n            char *op_code = \"111111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_SB:\r\n        {\r\n            char *op_code = \"101000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LD:\r\n        {\r\n            char *op_code = \"110111\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_LB:\r\n        {\r\n            char *op_code = \"100000\";\r\n            char *base = get_register_binary(curr->base);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char offset[33];\r\n            decimal_to_binary(atoi(curr->offset), offset, 16);\r\n            sprintf(binary_rep, \"%s%s%s%s\", op_code, base, rt, offset);\r\n            break;\r\n        }\r\n        case MIPS_DMULT:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011100\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_DDIV:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *rs = get_register_binary(curr->rs);\r\n            char *rt = get_register_binary(curr->rt);\r\n            char *sa = \"0000000000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, rs, rt, sa, funct);\r\n            break;\r\n        }\r\n        case MIPS_MFLO:\r\n        {\r\n            char *op_code = \"000000\";\r\n            char *sa = \"0000000000\";\r\n            char *rd = get_register_binary(curr->rd);\r\n            char *something = \"00000\";\r\n            char *funct = \"011111\";\r\n            sprintf(binary_rep, \"%s%s%s%s%s\", op_code, sa, rd, something, funct);\r\n            break;\r\n        }\r\n        default:\r\n            sprintf(binary_rep, \"00000000000000000000000000000000\\n\");\r\n            break;\r\n        }\r\n        fprintf(fp, \"%s\\n\", binary_rep);\r\n\r\n        if (fph)\r\n        {\r\n            unsigned long hex_rep = strtoul(binary_rep, NULL, 2);\r\n            fprintf(fph, \"0x%08lX\\n\", hex_rep);\r\n        }\r\n\r\n        curr = curr->next;\r\n    }\r\n\r\n    fclose(fp);\r\n\r\n    printf(\"Machine code written to %s\\n\", filename_binary);\r\n\r\n    if (fph)\r\n    {\r\n        fclose(fph);\r\n        printf(\"Machine code in hex format written to %s\\n\", filename_hex);\r\n    }\r\n}\r\n\r\nvoid parser_error(const char *message)\r\n{\r\n    record_error(current_token.line, message);\r\n}\r\n\r\n/**\r\n * returns 1 if expected token is found else add new error message to error stream and return 0;\r\n */\r\nint expect_token(TokenType expected)\r\n{\r\n    if (current_token.type == expected)\r\n    {\r\n        advance_token();\r\n        return 1;\r\n    }\r\n\r\n    char error_msg[256];\r\n    const char *expected_str =\r\n        (expected == TOK_INT)            ? \"TOK_INT\"\r\n        : (expected == TOK_CHAR)         ? \"TOK_CHAR\"\r\n        : (expected == TOK_IDENT)        ? \"TOK_IDENT\"\r\n        : (expected == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n        : (expected == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n        : (expected == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n        : (expected == TOK_PLUS_ASSIGN)  ? \"TOK_PLUS_ASSIGN\"\r\n        : (expected == TOK_MINUS_ASSIGN) ? \"TOK_MINUS_ASSIGN\"\r\n        : (expected == TOK_MULT_ASSIGN)  ? \"TOK_MULT_ASSIGN\"\r\n        : (expected == TOK_DIV_ASSIGN)   ? \"TOK_DIV_ASSIGN\"\r\n        : (expected == TOK_PLUS)         ? \"TOK_PLUS\"\r\n        : (expected == TOK_MINUS)        ? \"TOK_MINUS\"\r\n        : (expected == TOK_MULT)         ? \"TOK_MULT\"\r\n        : (expected == TOK_DIV)          ? \"TOK_DIV\"\r\n        : (expected == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n        : (expected == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n        : (expected == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n        : (expected == TOK_COMMA)        ? \"TOK_COMMA\"\r\n        : (expected == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n        : (expected == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n        : (expected == TOK_EOF)          ? \"TOK_EOF\"\r\n                                         : \"TOK_ERROR\";\r\n\r\n    snprintf(error_msg, sizeof(error_msg), \"Expected %s but found %s\",\r\n             expected_str,\r\n             (current_token.type == TOK_INT)            ? \"TOK_INT\"\r\n             : (current_token.type == TOK_CHAR)         ? \"TOK_CHAR\"\r\n             : (current_token.type == TOK_IDENT)        ? \"TOK_IDENT\"\r\n             : (current_token.type == TOK_NUMBER)       ? \"TOK_NUMBER\"\r\n             : (current_token.type == TOK_CHAR_LITERAL) ? \"TOK_CHAR_LITERAL\"\r\n             : (current_token.type == TOK_ASSIGN)       ? \"TOK_ASSIGN\"\r\n             : (current_token.type == TOK_PLUS)         ? \"TOK_PLUS\"\r\n             : (current_token.type == TOK_MINUS)        ? \"TOK_MINUS\"\r\n             : (current_token.type == TOK_MULT)         ? \"TOK_MULT\"\r\n             : (current_token.type == TOK_DIV)          ? \"TOK_DIV\"\r\n             : (current_token.type == TOK_SEMICOLON)    ? \"TOK_SEMICOLON\"\r\n             : (current_token.type == TOK_LPAREN)       ? \"TOK_LPAREN\"\r\n             : (current_token.type == TOK_RPAREN)       ? \"TOK_RPAREN\"\r\n             : (current_token.type == TOK_COMMA)        ? \"TOK_COMMA\"\r\n             : (current_token.type == TOK_INCREMENT)    ? \"TOK_INCREMENT\"\r\n             : (current_token.type == TOK_DECREMENT)    ? \"TOK_DECREMENT\"\r\n             : (current_token.type == TOK_EOF)          ? \"TOK_EOF\"\r\n                                                        : \"TOK_ERROR\");\r\n\r\n    parser_error(error_msg);\r\n    return 0;\r\n}\r\n\r\n// creates ast node in the linked list\r\nASTNode *create_ast_node(NodeType type, Token token, ASTNode *left, ASTNode *right)\r\n{\r\n    ASTNode *node = malloc(sizeof(ASTNode));\r\n    if (!node)\r\n    {\r\n        fprintf(stderr, \"Error: Failed to Allocate Memory for AST Node\\n\");\r\n        return NULL;\r\n    }\r\n    node->type = type;\r\n    node->token = token;\r\n    node->data_type = TYPE_UNKNOWN;\r\n    node->left = left;\r\n    node->right = right;\r\n    return node;\r\n}\r\n\r\nvoid print_indent(int depth)\r\n{\r\n    for (int i = 0; i < depth; ++i)\r\n        printf(\"  \");\r\n}\r\n\r\n/**\r\n * print_ast:\r\n * For Debugging , Prints the entire ast linked list\r\n */\r\nvoid print_ast(ASTNode *node, int depth)\r\n{\r\n    if (node == NULL)\r\n        return;\r\n\r\n    print_indent(depth);\r\n    const char *names[] = {\r\n        \"VAR_DECL\", \"ASSIGN\", \"BIN_OP\", \"NUMBER\", \"IDENT\",\r\n        \"PROGRAM\", \"STMT_LIST\", \"DECL_LIST\", \"CHAR_LITERAL\", \"UNARY_OP\", \"COMMA_EXPR\"};\r\n    if (node->type >= 0 && node->type <= NODE_COMMA_EXPR)\r\n        printf(\"%s\", names[node->type]);\r\n    else\r\n        printf(\"NODE?\");\r\n\r\n    if (node->type == NODE_IDENT || node->type == NODE_NUMBER ||\r\n        node->type == NODE_BIN_OP || node->type == NODE_VAR_DECL ||\r\n        node->type == NODE_CHAR_LITERAL || node->type == NODE_UNARY_OP ||\r\n        node->type == NODE_COMMA_EXPR)\r\n    {\r\n        printf(\" [%s]\", node->token.value);\r\n    }\r\n    printf(\"\\n\");\r\n\r\n    print_ast(node->left, depth + 1);\r\n    print_ast(node->right, depth + 1);\r\n}\r\n\r\nvoid free_ast(ASTNode *node)\r\n{\r\n    if (!node)\r\n        return;\r\n    free_ast(node->left);\r\n    free_ast(node->right);\r\n    free(node);\r\n}\r\n\r\n/*\r\nprogram → stmt_list TOK_EOF\r\n*/\r\nASTNode *parse_program()\r\n{\r\n    ASTNode *stmts = parse_stmt_list(); // Get Node for stmt_list\r\n    if (current_token.type != TOK_EOF)\r\n    {\r\n        parser_error(\"Expected EOF after program\");\r\n    }\r\n    ASTNode *program = create_ast_node(NODE_PROGRAM, create_token(TOK_EOF, NULL), stmts, NULL); // If no error then return the program ASTNode\r\n    return program;\r\n}\r\n\r\n/*\r\nstmt_list → stmt stmt_list | ε\r\n*/\r\nASTNode *parse_stmt_list()\r\n{\r\n    if (current_token.type == TOK_EOF)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *first = parse_stmt();\r\n    if (first == NULL)\r\n    {\r\n\r\n        while (current_token.type != TOK_EOF &&\r\n               current_token.type != TOK_INT &&\r\n               current_token.type != TOK_CHAR &&\r\n               current_token.type != TOK_IDENT)\r\n        {\r\n            advance_token();\r\n        }\r\n\r\n        if (current_token.type != TOK_EOF)\r\n        {\r\n            return parse_stmt_list();\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    ASTNode *head = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), first, NULL);\r\n    ASTNode *cur = head;\r\n\r\n    while (current_token.type != TOK_EOF)\r\n    {\r\n        ASTNode *next = parse_stmt();\r\n        if (next == NULL)\r\n        {\r\n\r\n            while (current_token.type != TOK_EOF &&\r\n                   current_token.type != TOK_INT &&\r\n                   current_token.type != TOK_CHAR &&\r\n                   current_token.type != TOK_IDENT)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_EOF)\r\n                break;\r\n            continue;\r\n        }\r\n\r\n        ASTNode *node = create_ast_node(NODE_STATEMENT_LIST, create_token(TOK_EOF, NULL), next, NULL);\r\n        cur->right = node;\r\n        cur = node;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n/*\r\nstmt → TOK_INT init_list TOK_SEMICOLON\r\n      | TOK_CHAR init_list TOK_SEMICOLON\r\n      | TOK_INCREMENT factor TOK_SEMICOLON\r\n      | TOK_DECREMENT factor TOK_SEMICOLON\r\n      | TOK_IDENT assignment TOK_SEMICOLON\r\n      | TOK_SEMICOLON\r\n\r\n*/\r\nASTNode *parse_stmt()\r\n{\r\n    if (current_token.type == TOK_INT || current_token.type == TOK_CHAR)\r\n    {\r\n        Token type_token = current_token;\r\n        advance_token();\r\n        ASTNode *decls = parse_init_list(type_token);\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            // This allows multiple semi colon at the end of the line e.g int a = b ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after declaration\");\r\n        }\r\n\r\n        return decls;\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        ASTNode *unary_stmt = parse_factor();\r\n        if (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        else\r\n            parser_error(\"Expected ';' after unary statement\");\r\n        return unary_stmt;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        ASTNode *assign_stmt = parse_assignment();\r\n\r\n        if (current_token.type == TOK_SEMICOLON)\r\n        {\r\n            while (current_token.type == TOK_SEMICOLON)\r\n                advance_token();\r\n        }\r\n        else\r\n        {\r\n            parser_error(\"Expected ';' after assignment\");\r\n        }\r\n\r\n        return assign_stmt;\r\n    }\r\n    else if (current_token.type == TOK_SEMICOLON)\r\n    {\r\n        while (current_token.type == TOK_SEMICOLON)\r\n            advance_token();\r\n        return NULL;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in statement\");\r\n        advance_token();\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\ninit_list → init | init TOK_COMMA init_list\r\n*/\r\nASTNode *parse_init_list(Token type_token)\r\n{\r\n    ASTNode *first_decl = parse_init(type_token);\r\n    if (first_decl == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        ASTNode *head = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), first_decl, NULL);\r\n        ASTNode *cur = head;\r\n        while (current_token.type == TOK_COMMA)\r\n        {\r\n            advance_token();\r\n            ASTNode *next_decl = parse_init(type_token);\r\n            if (next_decl == NULL)\r\n            {\r\n\r\n                while (current_token.type != TOK_EOF &&\r\n                       current_token.type != TOK_SEMICOLON &&\r\n                       current_token.type != TOK_IDENT)\r\n                {\r\n                    advance_token();\r\n                }\r\n                if (current_token.type == TOK_IDENT)\r\n                {\r\n                    next_decl = parse_init(type_token);\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (next_decl != NULL)\r\n            {\r\n                ASTNode *node = create_ast_node(NODE_DECL_LIST, create_token(TOK_EOF, NULL), next_decl, NULL);\r\n                cur->right = node;\r\n                cur = node;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n    else\r\n    {\r\n        return first_decl;\r\n    }\r\n}\r\n\r\n/*\r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n*/\r\nASTNode *parse_init(Token type_token)\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in declaration\");\r\n        return NULL;\r\n    }\r\n\r\n    // get the current token for the identifier\r\n    Token ident = current_token;\r\n    // Get the next/new token ahead of the idenfier\r\n    advance_token();\r\n\r\n    // Create the idenfier node . e.g int a;\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n    if (!ident_node)\r\n        return NULL;\r\n\r\n    // Create the declaration node e.g int a, b , c, d ..... ;\r\n    ASTNode *decl_node = create_ast_node(NODE_VAR_DECL, type_token, ident_node, NULL);\r\n\r\n    if (!decl_node)\r\n    {\r\n        free_ast(ident_node);\r\n        return NULL;\r\n    }\r\n\r\n    // If the current token is an ASSIGN token, then get the next token and parse the assignent expression.\r\n    if (current_token.type == TOK_ASSIGN)\r\n    {\r\n        advance_token();\r\n        ASTNode *expr = parse_assignment_expression();\r\n\r\n        // If the expr is valid , then the right side of the decl_node is set to the expr.\r\n        if (expr != NULL)\r\n        {\r\n            decl_node->right = expr;\r\n        }\r\n    }\r\n\r\n    return decl_node;\r\n}\r\n\r\n/*\r\nassignment → assignment_expression\r\n*/\r\nASTNode *parse_assignment()\r\n{\r\n    ASTNode *node = parse_assignment_expression();\r\n    if (!node)\r\n        parser_error(\"Invalid assignment statement\");\r\n    return node;\r\n}\r\n\r\n/*\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n*/\r\nASTNode *parse_assignment_expression()\r\n{\r\n    ASTNode *left = parse_additive_expression();\r\n\r\n    // Check for all assignment operators\r\n    if (current_token.type == TOK_ASSIGN ||\r\n        current_token.type == TOK_PLUS_ASSIGN ||\r\n        current_token.type == TOK_MINUS_ASSIGN ||\r\n        current_token.type == TOK_MULT_ASSIGN ||\r\n        current_token.type == TOK_DIV_ASSIGN)\r\n    {\r\n        if (left->type != NODE_IDENT)\r\n        {\r\n            parser_error(\"Left-hand side of assignment must be a variable\");\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        Token assign_tok = current_token;\r\n        TokenType op_type = current_token.type;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n            free_ast(left);\r\n            return NULL;\r\n        }\r\n\r\n        if (op_type != TOK_ASSIGN)\r\n        {\r\n            Token bin_op_token;\r\n            bin_op_token.line = assign_tok.line;\r\n\r\n            switch (op_type)\r\n            {\r\n            case TOK_PLUS_ASSIGN:\r\n                bin_op_token.type = TOK_PLUS;\r\n                strcpy(bin_op_token.value, \"+\");\r\n                break;\r\n            case TOK_MINUS_ASSIGN:\r\n                bin_op_token.type = TOK_MINUS;\r\n                strcpy(bin_op_token.value, \"-\");\r\n                break;\r\n            case TOK_MULT_ASSIGN:\r\n                bin_op_token.type = TOK_MULT;\r\n                strcpy(bin_op_token.value, \"*\");\r\n                break;\r\n            case TOK_DIV_ASSIGN:\r\n                bin_op_token.type = TOK_DIV;\r\n                strcpy(bin_op_token.value, \"/\");\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n\r\n            ASTNode *left_copy = create_ast_node(NODE_IDENT, left->token, NULL, NULL);\r\n            ASTNode *bin_op = create_ast_node(NODE_BIN_OP, bin_op_token, left_copy, right);\r\n\r\n            Token simple_assign = assign_tok;\r\n            simple_assign.type = TOK_ASSIGN;\r\n            strcpy(simple_assign.value, \"=\");\r\n\r\n            return create_ast_node(NODE_ASSIGN, simple_assign, left, bin_op);\r\n        }\r\n\r\n        return create_ast_node(NODE_ASSIGN, assign_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\ncomma_expression → assignment_expression | assignment_expression TOK_COMMA comma_expression\r\n*/\r\nASTNode *parse_comma_expression()\r\n{\r\n    ASTNode *left = parse_assignment_expression();\r\n    if (!left)\r\n        return NULL;\r\n\r\n    if (current_token.type == TOK_COMMA)\r\n    {\r\n        Token comma_tok = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *right = parse_comma_expression();\r\n        if (!right)\r\n        {\r\n\r\n            return left;\r\n        }\r\n\r\n        return create_ast_node(NODE_COMMA_EXPR, comma_tok, left, right);\r\n    }\r\n\r\n    return left;\r\n}\r\n\r\n/*\r\nadditive_expression → term additive_tail\r\n*/\r\nASTNode *parse_additive_expression()\r\n{\r\n    ASTNode *left = parse_term();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_additive_tail(left);\r\n}\r\n\r\n/*\r\n<additive_tail> ::= TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n*/\r\nASTNode *parse_additive_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_PLUS || current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_term();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nterm → factor term_tail\r\n*/\r\nASTNode *parse_term()\r\n{\r\n    ASTNode *left = parse_factor();\r\n    if (left == NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n    return parse_term_tail(left);\r\n}\r\n\r\n/*\r\n<term_tail> ::= TOK_MULT <factor> <term_tail>\r\n                    | TOK_DIV <factor> <term_tail>\r\n                    | ε\r\n*/\r\nASTNode *parse_term_tail(ASTNode *left)\r\n{\r\n    while (current_token.type == TOK_MULT || current_token.type == TOK_DIV)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return left;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, left, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(right);\r\n            return left;\r\n        }\r\n        left = bin;\r\n    }\r\n    return left;\r\n}\r\n\r\n/*\r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n*/\r\nASTNode *parse_factor()\r\n{\r\n    if (current_token.type == TOK_NUMBER)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_NUMBER, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_CHAR_LITERAL)\r\n    {\r\n        Token t = current_token;\r\n        advance_token();\r\n        return create_ast_node(NODE_CHAR_LITERAL, t, NULL, NULL);\r\n    }\r\n    else if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op_token = current_token;\r\n        advance_token();\r\n\r\n        if (current_token.type != TOK_IDENT)\r\n        {\r\n            parser_error(\"Expected identifier after prefix ++ or --\");\r\n            return NULL;\r\n        }\r\n\r\n        ASTNode *id_node = create_ast_node(NODE_IDENT, current_token, NULL, NULL);\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op_token, id_node, NULL);\r\n\r\n        advance_token();\r\n        return unary_node;\r\n    }\r\n    else if (current_token.type == TOK_IDENT)\r\n    {\r\n        return parse_postfix_expression();\r\n    }\r\n    else if (current_token.type == TOK_LPAREN)\r\n    {\r\n        advance_token();\r\n\r\n        ASTNode *expr = parse_comma_expression();\r\n        if (expr == NULL)\r\n        {\r\n            while (current_token.type != TOK_EOF && current_token.type != TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            if (current_token.type == TOK_RPAREN)\r\n            {\r\n                advance_token();\r\n            }\r\n            return NULL;\r\n        }\r\n        if (!expect_token(TOK_RPAREN))\r\n        {\r\n            // Error already recorded\r\n        }\r\n        return expr;\r\n    }\r\n    else if (current_token.type == TOK_PLUS)\r\n    {\r\n        advance_token();\r\n        ASTNode *inner = parse_factor();\r\n        return inner;\r\n    }\r\n    else if (current_token.type == TOK_MINUS)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n        ASTNode *right = parse_factor();\r\n        if (right == NULL)\r\n        {\r\n            return NULL;\r\n        }\r\n        Token zero_tok = create_token(TOK_NUMBER, \"0\");\r\n        ASTNode *zero_node = create_ast_node(NODE_NUMBER, zero_tok, NULL, NULL);\r\n        if (!zero_node)\r\n        {\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        ASTNode *bin = create_ast_node(NODE_BIN_OP, op, zero_node, right);\r\n        if (!bin)\r\n        {\r\n            free_ast(zero_node);\r\n            free_ast(right);\r\n            return NULL;\r\n        }\r\n        return bin;\r\n    }\r\n    else\r\n    {\r\n        parser_error(\"Unexpected token in factor\");\r\n        return NULL;\r\n    }\r\n}\r\n\r\n/*\r\npostfix_expression → TOK_IDENT | TOK_IDENT TOK_INCREMENT | TOK_IDENT TOK_DECREMENT\r\n*/\r\nASTNode *parse_postfix_expression()\r\n{\r\n    if (current_token.type != TOK_IDENT)\r\n    {\r\n        parser_error(\"Expected identifier in postfix expression\");\r\n        return NULL;\r\n    }\r\n\r\n    Token ident = current_token;\r\n    advance_token();\r\n\r\n    ASTNode *ident_node = create_ast_node(NODE_IDENT, ident, NULL, NULL);\r\n\r\n    if (current_token.type == TOK_INCREMENT || current_token.type == TOK_DECREMENT)\r\n    {\r\n        Token op = current_token;\r\n        advance_token();\r\n\r\n        ASTNode *unary_node = create_ast_node(NODE_UNARY_OP, op, ident_node, NULL);\r\n        return unary_node;\r\n    }\r\n\r\n    return ident_node;\r\n}\r\n\r\n/*\r\nexpression → assignment_expression\r\n*/\r\nASTNode *parse_expression()\r\n{\r\n    return parse_assignment_expression();\r\n}\r\n\r\n// Init lexer -- clear exisitng lexer\r\nvoid init_lexer(const char *input_str)\r\n{\r\n    if (input)\r\n        free(input);\r\n    input = strdup(input_str);\r\n    position = 0;\r\n    current_line = 1;\r\n}\r\n\r\n// Function to create token in the linked list\r\nToken create_token(TokenType type, const char *value)\r\n{\r\n    Token token;\r\n    token.type = type;\r\n    if (value)\r\n    {\r\n        strncpy(token.value, value, sizeof(token.value) - 1);\r\n        token.value[sizeof(token.value) - 1] = '\\0';\r\n    }\r\n    else\r\n    {\r\n        token.value[0] = '\\0';\r\n    }\r\n    token.line = current_line;\r\n    return token;\r\n}\r\n\r\n// Helper function to check if character is valid char\r\nint is_identifier_char(char c)\r\n{\r\n    return isalnum((unsigned char)c) || c == '_';\r\n}\r\n\r\n// Lexer function to get the next token\r\nToken get_next_token()\r\n{\r\n    // Ignore white spaces\r\n    while (isspace((unsigned char)input[position]))\r\n    {\r\n        if (input[position] == '\\n')\r\n            current_line++;\r\n        position++;\r\n    }\r\n\r\n    // Ignore Comments and check for /=\r\n    if (input[position] == '/')\r\n    {\r\n        if (input[position + 1] == '/')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0' && input[position] != '\\n')\r\n                position++;\r\n            return get_next_token();\r\n        }\r\n\r\n        if (input[position + 1] == '*')\r\n        {\r\n            position += 2;\r\n            while (input[position] != '\\0')\r\n            {\r\n                if (input[position] == '*' && input[position + 1] == '/')\r\n                {\r\n                    position += 2;\r\n                    break;\r\n                }\r\n                if (input[position] == '\\n')\r\n                    current_line++;\r\n                position++;\r\n            }\r\n            return get_next_token();\r\n        }\r\n\r\n        // Check for /= BEFORE returning single /\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DIV_ASSIGN, \"/=\");\r\n        }\r\n\r\n        // Single division operator\r\n        position++;\r\n        return create_token(TOK_DIV, \"/\");\r\n    }\r\n\r\n    // Token for end of file\r\n    if (input[position] == '\\0')\r\n    {\r\n        return create_token(TOK_EOF, NULL);\r\n    }\r\n\r\n    // Check for ++ and += before single +\r\n    if (input[position] == '+')\r\n    {\r\n        if (input[position + 1] == '+')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_INCREMENT, \"++\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_PLUS_ASSIGN, \"+=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_PLUS, \"+\");\r\n    }\r\n\r\n    // Check for -- and -= before single -\r\n    if (input[position] == '-')\r\n    {\r\n        if (input[position + 1] == '-')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_DECREMENT, \"--\");\r\n        }\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MINUS_ASSIGN, \"-=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MINUS, \"-\");\r\n    }\r\n\r\n    // Check for *= before single *\r\n    if (input[position] == '*')\r\n    {\r\n        if (input[position + 1] == '=')\r\n        {\r\n            position += 2;\r\n            return create_token(TOK_MULT_ASSIGN, \"*=\");\r\n        }\r\n        position++;\r\n        return create_token(TOK_MULT, \"*\");\r\n    }\r\n\r\n    // Token for Escape Sequences\r\n    if (input[position] == '\\'')\r\n    {\r\n        position++;\r\n        char char_val[4] = {0};\r\n        int i = 0;\r\n\r\n        if (input[position] == '\\\\')\r\n        {\r\n            char_val[i++] = input[position++];\r\n            if (i < 3)\r\n                char_val[i++] = input[position++];\r\n        }\r\n        else if (input[position] != '\\'' && input[position] != '\\0')\r\n        {\r\n            char_val[i++] = input[position++];\r\n        }\r\n\r\n        if (input[position] != '\\'')\r\n        {\r\n            return create_token(TOK_ERROR, \"Unterminated character literal\");\r\n        }\r\n        position++;\r\n\r\n        return create_token(TOK_CHAR_LITERAL, char_val);\r\n    }\r\n\r\n    // Token for stream of alpha characters or starting with _\r\n    if (isalpha((unsigned char)input[position]) || input[position] == '_')\r\n    {\r\n        char ident[32] = {0};\r\n        int i = 0;\r\n\r\n        while (is_identifier_char(input[position]) && i < 31)\r\n        {\r\n            ident[i++] = input[position++];\r\n        }\r\n        ident[i] = '\\0';\r\n        // Check if token is reserved keywords for data types\r\n        if (strcmp(ident, \"int\") == 0)\r\n            return create_token(TOK_INT, ident);\r\n        if (strcmp(ident, \"char\") == 0)\r\n            return create_token(TOK_CHAR, ident);\r\n        // if not then it is identifier\r\n        return create_token(TOK_IDENT, ident);\r\n    }\r\n\r\n    // Token for number\r\n    if (isdigit((unsigned char)input[position]))\r\n    {\r\n        char number[32] = {0};\r\n        int i = 0;\r\n\r\n        while (isdigit((unsigned char)input[position]) && i < 31)\r\n        {\r\n            number[i++] = input[position++];\r\n        }\r\n        number[i] = '\\0';\r\n\r\n        return create_token(TOK_NUMBER, number);\r\n    }\r\n\r\n    char current = input[position++];\r\n    // Token for Operators\r\n    switch (current)\r\n    {\r\n    case '=':\r\n        return create_token(TOK_ASSIGN, \"=\");\r\n    case ';':\r\n        return create_token(TOK_SEMICOLON, \";\");\r\n    case '(':\r\n        return create_token(TOK_LPAREN, \"(\");\r\n    case ')':\r\n        return create_token(TOK_RPAREN, \")\");\r\n    case ',':\r\n        return create_token(TOK_COMMA, \",\");\r\n    }\r\n    // Token for unidentified symbols\r\n    char error[2] = {current, '\\0'};\r\n    return create_token(TOK_ERROR, error);\r\n}\r\n\r\nvoid advance_token()\r\n{\r\n    current_token = get_next_token();\r\n}\r\n\r\n/**\r\n * read_file:\r\n * Reads the entire contents of a file into a dynamically allocated string.\r\n * Parameters:\r\n *  - filename: the name of the file to read\r\n * Returns:\r\n * - a pointer to the dynamically allocated string containing the file contents\r\n */\r\nchar *read_file(char *filename)\r\n{\r\n    FILE *file = fopen(filename, \"rb\"); // Open File in Read Binary Mode\r\n\r\n    if (file == NULL) // Check if file opened successfully\r\n    {\r\n        fprintf(stderr, \"Error: Cannot open file '%s'\\n\", filename);\r\n        return NULL;\r\n    }\r\n\r\n    fseek(file, 0, SEEK_END);     // Move to end of file\r\n    long file_size = ftell(file); // Get current position (file size)\r\n    fseek(file, 0, SEEK_SET);     // Move back to beginning of file\r\n\r\n    if (file_size <= 0) // Check if file is empty\r\n    {\r\n        fprintf(stderr, \"Error: File '%s' is empty or cannot be read\\n\", filename);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    char *buffer = malloc(file_size + 1); // Allocate memory for file contents + null terminator\r\n    if (buffer == NULL)                   // Check if memory allocation was successful\r\n    {\r\n        fprintf(stderr, \"Error: Memory allocation failed\\n\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    size_t bytes_read = fread(buffer, 1, file_size, file); // Read file contents into buffer\r\n    if (bytes_read != (size_t)file_size)                   // Check if all bytes were read\r\n    {\r\n        fprintf(stderr, \"Warning: only read %zu of %ld bytes\\n\", bytes_read, file_size);\r\n    }\r\n\r\n    buffer[bytes_read] = '\\0'; // Null-terminate the string\r\n    fclose(file);              // Close the file\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * process_file:\r\n * Processes a source code file: reads, tokenizes, parses, performs semantic analysis,\r\n * generates TAC, and outputs MIPS assembly and machine code.\r\n * Parameters:\r\n * - filename: the name of the source code file to process\r\n * Returns: void\r\n */\r\nvoid process_file(char *filename)\r\n{\r\n    printf(\"Processing file: %s\\n\", filename);\r\n    char *source_code = read_file(filename);\r\n    if (source_code == NULL)\r\n        return;\r\n\r\n    init_lexer(source_code);        // Initialize Lexer\r\n    init_symbol_table();            // Intialize Symbol table\r\n    advance_token();                // Get the first token in the source code\r\n    ASTNode *ast = parse_program(); // Parse the source code\r\n    TACNode *tac = NULL;            // Declare TAC\r\n\r\n    semantic_analysis(ast); // Check Semantics\r\n\r\n    if (error_count > 0)\r\n    {\r\n        print_errors();\r\n    }\r\n    else\r\n    {\r\n        tac = generate_tac(ast); // If no syntax and symantic errors then generate TAC\r\n        if (tac)\r\n        {\r\n            assembly_code = generate_assembly_code(tac); // if tac is generated successfuly then generate assembly code.\r\n            if (assembly_code)                           // If assembly is generated successfully , generate machine code\r\n            {\r\n                write_assembly_to_file(assembly_code, \"output_mips64.txt\");\r\n                write_machine_code_to_file(assembly_code, \"output_machine_code_binary.txt\", \"output_machine_code_hex.txt\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (DEBUG_MODE) // Switch for debug mode\r\n    {\r\n        printf(\"DEBUG MODE TRUE: Printing AST , SYMBOL TABLE AND TAC.\\n\");\r\n        printf(\"\\n===== AST =====\\n\");\r\n        print_ast(ast, 0);\r\n        print_symbol_table();\r\n        print_errors();\r\n\r\n        if (error_count == 0)\r\n        {\r\n            print_tac(tac);\r\n        }\r\n    }\r\n\r\n    // Free Allocated Memories\r\n    free_ast(ast);\r\n    free_tac(tac);\r\n    free_mips_instructions(assembly_code);\r\n    free_symbol_table();\r\n    free(source_code);\r\n    clear_errors();\r\n}"
    }
  ]
}
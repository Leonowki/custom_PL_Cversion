{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "SIMULATE_C_LANG",
  "steps": [
    {
      "file": "c_based_language.c",
      "description": "## process_file(char *filename)\r\nThis is the starting point of the program . This processes the file based on the input.\r\nThis calls the functions to initialize the lexer , symbol table , ast parser , tac , and generate assembly code as well as clean up memory.",
      "line": 368
    },
    {
      "file": "c_based_language.c",
      "description": "## init_lexer\r\nThis function initializes the lexer:\r\n* Sets the input source code\r\n* Resets the values of the lexer global variables to the initial state",
      "line": 3125
    },
    {
      "file": "c_based_language.c",
      "description": "## init_symbol_table\r\nSimilar to the init_lexer it also resets the global variables for the symbol table to its initial values.",
      "line": 3126
    },
    {
      "file": "c_based_language.c",
      "description": "## advance_token\r\n\r\n* This is the lexer function to get the next token from the source code.\r\n* We are calling this function once before calling the parser so that the current_token variable is not empty and is initialized with the first token in from the source code.",
      "line": 3127
    },
    {
      "file": "c_based_language.c",
      "description": "## Head node for the ast generated via parse_program function\r\n\r\n* This line calls the parse_program function, which is the program production rule on the CFG.\r\n* This processes the lexer using a top-down approach and recursive decent.\r\n* Each function calls other functions recursively based on what productions match — starting from the root nonterminal (e.g., program) and descending down into smaller constructs. - This is recursive decent.",
      "line": 3128
    },
    {
      "file": "c_based_language.c",
      "description": "## parse_program **program** production rule\r\n* This is the function definition for the *program* production rule\r\n* Following the defined rule , it does the following:\r\n    1. Parse the stmt_list first\r\n    2. Check if the current_token after stmt_list is processed is of type EOF. If not, then something went wrong with the parsing or source code -> add parse error.\r\n    3. Create a node for the ast_linked list and return the node, this will be used as the head/root of the ast parse tree based on the function call from process_file",
      "line": 2252
    },
    {
      "file": "c_based_language.c",
      "description": "### Production rule for ε in the stmt_list\r\n\r\n* This corresponds to the ε (epsilon) rule.\r\n* If we’ve reached the end of the file, that means there are no more statements, so the parser returns NULL to represent the empty production (stmt_list -> ε).",
      "line": 2264
    },
    {
      "file": "c_based_language.c",
      "description": "### Parse first_stmt and Error Recovery\r\n\r\n* Calls parse_stmt() to parse the first statement in the list.\r\n* If that fails (first == NULL), it tries to recover:\r\n    * It skips tokens until it finds something that could start a new statement (like int, char, or an identifier).\r\n    * Then it recursively calls itself again, effectively saying:\r\n            “Okay, that statement failed, so skip it, and try parsing the next one.”",
      "line": 2284
    },
    {
      "file": "c_based_language.c",
      "description": "## Iterative approach to the production rule stmt_list → stmt stmt_list.\r\n\r\n* next - the left node for the stmt_list production rule.\r\n    * If next is null, for error recovery , get the next valid token for the production rule.\r\n* create an ast node in the tree and set that node, which holds the next ast node as the right node for the current stmt_list node.",
      "line": 2289
    },
    {
      "file": "c_based_language.c",
      "description": "## parse_stmt\r\n\r\n* Parses the stmt production rule based on the following production rules: \r\n1. TOK_INT init_list TOK_SEMICOLON \r\n2. TOK_CHAR init_list TOK_SEMICOLON\r\n3. TOK_INCREMENT factor TOK_SEMICOLON\r\n4. TOK_DECREMENT factor TOK_SEMICOLON\r\n5. TOK_IDENT assignment TOK_SEMICOLON\r\n6. TOK_SEMICOLON",
      "line": 2324
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_init_list`\r\n\r\n**Grammar:**\r\n\r\n\r\n**Purpose:**  \r\nParses a comma-separated list of variable initializations in a declaration,  \r\ne.g. `nmbr a = 1, b = 2, c;`.\r\n\r\n**How it works:**  \r\n1. Parses the first variable (`parse_init()`).\r\n2. If a comma is found, repeatedly parses more `init` entries.\r\n3. Builds a linked AST list (`NODE_DECL_LIST`) for each variable.\r\n4. Includes **error recovery**:  \r\n   if an invalid token appears (like `int a, , b;`),  \r\n   the parser skips until it finds a valid identifier or semicolon.",
      "line": 2334
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_init`\r\n\r\n**Grammar:**  \r\ninit → TOK_IDENT | TOK_IDENT TOK_ASSIGN assignment_expression\r\n\r\n**Purpose:**  \r\nParses a **single variable initialization** (declaration) within a declaration list: \r\n\r\ne.g.  \r\n\r\nint a;\r\nint b = 10;\r\nchar c = 'A';",
      "line": 2401
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_assignment_expression`\r\n\r\n**Grammar:**  \r\n\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n\r\n**Purpose:**  \r\nParses an **assignment expression**, including both **simple assignments** and **compound assignments**, such as:\r\n\r\na = 5;\r\nb += 3;\r\ntotal *= rate + tax;",
      "line": 2490,
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 12,
          "character": 21
        }
      }
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_additive_expression`\r\n\r\n**Grammar:**  \r\n\r\nadditive_expression → term additive_tail\r\n\r\n\r\n---\r\n\r\n**Purpose:**  \r\nParses **addition and subtraction** expressions — that is, expressions involving the `+` and `-` operators.  \r\nThis rule forms the basis of arithmetic evaluation in expressions like:\r\n\r\n\r\na + b\r\n\r\nx - y + z\r\n",
      "line": 2518
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_term`\r\n\r\n**Grammar:**  \r\n\r\nterm → factor term_tail\r\n\r\n\r\n---\r\n\r\n**Purpose:**  \r\nParses a **term** in an arithmetic expression, which consists of a **factor** potentially followed by multiplication or division operations.  \r\nThis corresponds to the left-hand side of additive expressions, e.g., in:\r\n\r\n\r\na * b / c\r\n",
      "line": 2620
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_factor`\r\n\r\n**Grammar:**  \r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n\r\n**Purpose:**  \r\nParses the **lowest-level expressions** (operands) in arithmetic or assignment expressions.  \r\nThese are the building blocks used by higher-level grammar rules like `term` and `additive_expression`.\r\n\r\n**How it works:**  \r\n\r\n1. **Literals**\r\n   - If the token is a number (`TOK_NUMBER`) → creates a `NODE_NUMBER`.\r\n   - If it’s a character literal (`TOK_CHAR_LITERAL`) → creates a `NODE_CHAR_LITERAL`.\r\n\r\n2. **Prefix Increment/Decrement**\r\n   - Handles prefix operators like `++a` or `--b`.\r\n   - Ensures the next token is an identifier, else reports an error.\r\n   - Creates a `NODE_UNARY_OP` node with the operator and identifier.\r\n\r\n3. **Identifiers**\r\n   - Calls `parse_postfix_expression()` to handle things like post-increment (`a++`) or `a--`.\r\n\r\n4. **Parenthesized Expressions**\r\n   - Handles expressions in parentheses:  \r\n     e.g. `(a + b * c)`\r\n   - If parsing fails, it performs **error recovery** by skipping ahead to `TOK_RPAREN` or `TOK_EOF`.\r\n\r\n5. **Unary Operators**\r\n   - Handles unary `+` and `-` before a factor.\r\n   - For `-x`, it builds an equivalent binary node `0 - x`.\r\n\r\n6. **Error Handling**\r\n   - If none of the above match, it triggers a syntax error:  \r\n     `\"Unexpected token in factor\"`.\r\n",
      "line": 2660
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_term_tail`\r\n\r\n**Grammar:**  \r\nterm_tail -> TOK_MULT factor term_tail | TOK_DIV factor term_tail | ε\r\n\r\n\r\n---\r\n\r\n**Purpose:**  \r\nParses the **multiplicative tail** of a term in an arithmetic expression.  \r\nHandles sequences of multiplication (`*`) and division (`/`) operations after an initial factor.  \r\nImplements **left-associativity** for operators like:\r\n\r\n\r\na * b / c * d\r\n",
      "line": 2665
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_additive_tail`\r\n\r\n**Grammar:**  \r\n\r\n\r\nadditive_tail -> TOK_PLUS <term> <additive_tail>\r\n                        | TOK_MINUS <term> <additive_tail>\r\n                        | ε\r\n\r\n\r\n---\r\n\r\n**Purpose:**  \r\nParses the *tail* of an additive expression — handling **repeated addition and subtraction** operations after the first term.  \r\nIt effectively builds left-associative binary operator trees for expressions like:\r\n\r\n\r\na + b - c + d\r\n",
      "line": 2625
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_comma_expression`\r\n\r\n**Grammar:**  \r\ncomma_expression → assignment_expression\r\n| assignment_expression TOK_COMMA comma_expression\r\n\r\n\r\n---\r\n\r\n**Purpose:**  \r\nParses expressions that use the **comma operator**, allowing multiple expressions to be evaluated in sequence.  \r\nExample:\r\n\r\n\r\na = 1, b = 2, a + b\r\n",
      "line": 2538
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_factor`\r\n\r\n**Grammar:**  \r\nfactor → TOK_NUMBER | TOK_CHAR_LITERAL\r\n        | TOK_INCREMENT TOK_IDENT\r\n        | TOK_DECREMENT TOK_IDENT\r\n        | TOK_IDENT\r\n        | TOK_IDENT TOK_INCREMENT\r\n        | TOK_IDENT TOK_DECREMENT\r\n        | TOK_LPAREN comma_expression TOK_RPAREN\r\n        | TOK_PLUS factor\r\n        | TOK_MINUS factor\r\n\r\n**Purpose:**  \r\nParses the **lowest-level expressions** (operands) in arithmetic or assignment expressions.  \r\nThese are the building blocks used by higher-level grammar rules like `term` and `additive_expression`.\r\n\r\n**How it works:**  \r\n\r\n1. **Literals**\r\n   - If the token is a number (`TOK_NUMBER`) → creates a `NODE_NUMBER`.\r\n   - If it’s a character literal (`TOK_CHAR_LITERAL`) → creates a `NODE_CHAR_LITERAL`.\r\n\r\n2. **Prefix Increment/Decrement**\r\n   - Handles prefix operators like `++a` or `--b`.\r\n   - Ensures the next token is an identifier, else reports an error.\r\n   - Creates a `NODE_UNARY_OP` node with the operator and identifier.\r\n\r\n3. **Identifiers**\r\n   - Calls `parse_postfix_expression()` to handle things like post-increment (`a++`) or `a--`.\r\n\r\n4. **Parenthesized Expressions**\r\n   - Handles expressions in parentheses:  \r\n     e.g. `(a + b * c)`\r\n   - If parsing fails, it performs **error recovery** by skipping ahead to `TOK_RPAREN` or `TOK_EOF`.\r\n\r\n5. **Unary Operators**\r\n   - Handles unary `+` and `-` before a factor.\r\n   - For `-x`, it builds an equivalent binary node `0 - x`.\r\n\r\n6. **Error Handling**\r\n   - If none of the above match, it triggers a syntax error:  \r\n     `\"Unexpected token in factor\"`.\r\n",
      "line": 2355
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_postfix_expression`\r\n\r\npostfix_expression → TOK_IDENT\r\n| TOK_IDENT TOK_INCREMENT\r\n| TOK_IDENT TOK_DECREMENT\r\n\r\n\r\n---\r\n\r\n**Purpose:**  \r\nParses **postfix expressions** that involve identifiers, optionally followed by postfix increment (`++`) or decrement (`--`) operators.  \r\nThese are expressions like:\r\n\r\n\r\nx\r\n\r\nx++\r\n\r\nx--\r\n\r\n\r\n",
      "line": 2739
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_comma_expression`\r\n\r\n**Grammar:**  \r\ncomma_expression → assignment_expression\r\n| assignment_expression TOK_COMMA comma_expression\r\n\r\n\r\n---\r\n\r\n**Purpose:**  \r\nParses expressions that use the **comma operator**, allowing multiple expressions to be evaluated in sequence.  \r\nExample:\r\n\r\n\r\na = 1, b = 2, a + b\r\n",
      "line": 2745
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_assignment_expression`\r\n\r\n**Grammar:**  \r\n\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n\r\n**Purpose:**  \r\nParses an **assignment expression**, including both **simple assignments** and **compound assignments**, such as:\r\n\r\na = 5;\r\nb += 3;\r\ntotal *= rate + tax;",
      "line": 2593
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_assignment`\r\n\r\n**Grammar:**  \r\nassignment → assignment_expression\r\n\r\n**Purpose:**  \r\nThis function acts as a **wrapper rule** for parsing an assignment statement.  \r\nIt delegates the actual parsing logic to `parse_assignment_expression()` and performs basic **error checking**.\r\n\r\n---\r\n\r\n**How it works:**\r\n\r\n1. Calls `parse_assignment_expression()` to attempt parsing an expression that may contain:\r\n   - Simple assignments (`a = 5`)\r\n   - Compound assignments (`a += 2`, `b *= 3`)\r\n   - Or even nested expressions (`a = b + c * d`)\r\n\r\n2. If the returned node is `NULL`, it reports a **parser error** using:\r\n   ```c\r\n   parser_error(\"Invalid assignment statement\");",
      "line": 2366
    },
    {
      "file": "c_based_language.c",
      "description": "### Function: `parse_assignment_expression`\r\n\r\n**Grammar:**  \r\n\r\nassignment_expression → additive_expression | TOK_IDENT assign_op comma_expression\r\n\r\n**Purpose:**  \r\nParses an **assignment expression**, including both **simple assignments** and **compound assignments**, such as:\r\n\r\na = 5;\r\nb += 3;\r\ntotal *= rate + tax;",
      "line": 2507
    }
  ],
  "ref": "Redocumented"
}